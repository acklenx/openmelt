
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000003a  00800100  00002522  000025d6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002522  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000008c  0080013a  0080013a  00002610  2**0
                  ALLOC
  3 .eeprom       0000000c  00810000  00810000  00002610  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 00000020  00000000  00000000  0000261c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 00000667  00000000  00000000  0000263c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000f98  00000000  00000000  00002ca3  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000294  00000000  00000000  00003c3b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000e78  00000000  00000000  00003ecf  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000180  00000000  00000000  00004d48  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000005f5  00000000  00000000  00004ec8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000619  00000000  00000000  000054bd  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001b0  00000000  00000000  00005ad6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 19 06 	jmp	0xc32	; 0xc32 <__vector_3>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d4 e0       	ldi	r29, 0x04	; 4
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e2 e2       	ldi	r30, 0x22	; 34
      7c:	f5 e2       	ldi	r31, 0x25	; 37
      7e:	02 c0       	rjmp	.+4      	; 0x84 <.do_copy_data_start>

00000080 <.do_copy_data_loop>:
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0

00000084 <.do_copy_data_start>:
      84:	aa 33       	cpi	r26, 0x3A	; 58
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <.do_copy_data_loop>

0000008a <__do_clear_bss>:
      8a:	11 e0       	ldi	r17, 0x01	; 1
      8c:	aa e3       	ldi	r26, 0x3A	; 58
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a6 3c       	cpi	r26, 0xC6	; 198
      96:	b1 07       	cpc	r27, r17
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <main>
      9e:	0c 94 8f 12 	jmp	0x251e	; 0x251e <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
      a6:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
      a8:	f9 99       	sbic	0x1f, 1	; 31
      aa:	fe cf       	rjmp	.-4      	; 0xa8 <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
      ac:	32 bd       	out	0x22, r19	; 34
      ae:	21 bd       	out	0x21, r18	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
      b0:	f8 9a       	sbi	0x1f, 0	; 31
      b2:	80 b5       	in	r24, 0x20	; 32
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
      b4:	08 95       	ret

000000b6 <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
      b6:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
      b8:	f9 99       	sbic	0x1f, 1	; 31
      ba:	fe cf       	rjmp	.-4      	; 0xb8 <eeprom_write_byte+0x2>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
      bc:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
      be:	32 bd       	out	0x22, r19	; 34
      c0:	21 bd       	out	0x21, r18	; 33
#endif
    EEDR = __value;
      c2:	60 bd       	out	0x20, r22	; 32

    __asm__ __volatile__ (
      c4:	0f b6       	in	r0, 0x3f	; 63
      c6:	f8 94       	cli
      c8:	fa 9a       	sbi	0x1f, 2	; 31
      ca:	f9 9a       	sbi	0x1f, 1	; 31
      cc:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
      ce:	08 95       	ret

000000d0 <get_config_constants>:


}

void get_config_constants(void)
{
      d0:	cf 93       	push	r28
      d2:	df 93       	push	r29
      d4:	e0 e0       	ldi	r30, 0x00	; 0
      d6:	f0 e0       	ldi	r31, 0x00	; 0
      d8:	20 e0       	ldi	r18, 0x00	; 0
      da:	30 e0       	ldi	r19, 0x00	; 0
      dc:	40 e0       	ldi	r20, 0x00	; 0
      de:	50 e0       	ldi	r21, 0x00	; 0
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
      e0:	a0 e5       	ldi	r26, 0x50	; 80
      e2:	b3 ec       	ldi	r27, 0xC3	; 195
      e4:	1b c0       	rjmp	.+54     	; 0x11c <get_config_constants+0x4c>
{

    unsigned int adc_data;
	
	// Start conversion by setting ADSC on ADCSRA Register
	  ADCSRA |= (1<<ADSC);
      e6:	80 91 7a 00 	lds	r24, 0x007A
      ea:	80 64       	ori	r24, 0x40	; 64
      ec:	80 93 7a 00 	sts	0x007A, r24

	// wait until convertion complete ADSC=0 -> Complete
    while (ADCSRA & (1<<ADSC));
      f0:	80 91 7a 00 	lds	r24, 0x007A
      f4:	86 fd       	sbrc	r24, 6
      f6:	fc cf       	rjmp	.-8      	; 0xf0 <get_config_constants+0x20>
	    
	adc_data = ADCL;   
      f8:	90 91 78 00 	lds	r25, 0x0078

	//shift from low level to high level ADC, from 8bit to 10bit

	adc_data += (ADCH<<8);	  
      fc:	80 91 79 00 	lds	r24, 0x0079
	// sample and set the accelerometer base value (average a bunch of samples)

	base_accel = 0;
	for (x = 0; x < 20; x++)
	{
		base_accel = base_accel + read_adc();               				//get accel data
     100:	78 2f       	mov	r23, r24
     102:	60 e0       	ldi	r22, 0x00	; 0
     104:	eb 01       	movw	r28, r22
     106:	c9 0f       	add	r28, r25
     108:	d1 1d       	adc	r29, r1
     10a:	ec 0f       	add	r30, r28
     10c:	fd 1f       	adc	r31, r29
     10e:	cd 01       	movw	r24, r26
     110:	01 97       	sbiw	r24, 0x01	; 1
     112:	f1 f7       	brne	.-4      	; 0x110 <get_config_constants+0x40>
     114:	2f 5f       	subi	r18, 0xFF	; 255
     116:	3f 4f       	sbci	r19, 0xFF	; 255
     118:	4f 4f       	sbci	r20, 0xFF	; 255
     11a:	5f 4f       	sbci	r21, 0xFF	; 255
{

	// sample and set the accelerometer base value (average a bunch of samples)

	base_accel = 0;
	for (x = 0; x < 20; x++)
     11c:	24 31       	cpi	r18, 0x14	; 20
     11e:	31 05       	cpc	r19, r1
     120:	41 05       	cpc	r20, r1
     122:	51 05       	cpc	r21, r1
     124:	04 f3       	brlt	.-64     	; 0xe6 <get_config_constants+0x16>
	{
		base_accel = base_accel + read_adc();               				//get accel data
		_delay_ms(10);
	}
	base_accel = base_accel / 20;
     126:	cf 01       	movw	r24, r30
     128:	64 e1       	ldi	r22, 0x14	; 20
     12a:	70 e0       	ldi	r23, 0x00	; 0
     12c:	0e 94 3f 12 	call	0x247e	; 0x247e <__divmodhi4>
     130:	70 93 35 01 	sts	0x0135, r23
     134:	60 93 34 01 	sts	0x0134, r22
     138:	60 e0       	ldi	r22, 0x00	; 0
     13a:	70 e0       	ldi	r23, 0x00	; 0
     13c:	20 e0       	ldi	r18, 0x00	; 0
     13e:	30 e0       	ldi	r19, 0x00	; 0
     140:	40 e0       	ldi	r20, 0x00	; 0
     142:	50 e0       	ldi	r21, 0x00	; 0
     144:	c4 ef       	ldi	r28, 0xF4	; 244
     146:	d1 e0       	ldi	r29, 0x01	; 1
     148:	15 c0       	rjmp	.+42     	; 0x174 <get_config_constants+0xa4>
	// sample and set the left / right center value for the control stick (average a bunch of samples)

	heading_center = 0;
	for (x = 0; x < 20; x++)
	{
		heading_center = heading_center + leftright;               		
     14a:	80 91 8e 01 	lds	r24, 0x018E
     14e:	90 91 8f 01 	lds	r25, 0x018F
     152:	a0 91 90 01 	lds	r26, 0x0190
     156:	b0 91 91 01 	lds	r27, 0x0191
     15a:	68 0f       	add	r22, r24
     15c:	79 1f       	adc	r23, r25
     15e:	88 ec       	ldi	r24, 0xC8	; 200
     160:	90 e0       	ldi	r25, 0x00	; 0
     162:	fe 01       	movw	r30, r28
     164:	31 97       	sbiw	r30, 0x01	; 1
     166:	f1 f7       	brne	.-4      	; 0x164 <get_config_constants+0x94>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     168:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     16a:	d9 f7       	brne	.-10     	; 0x162 <get_config_constants+0x92>
     16c:	2f 5f       	subi	r18, 0xFF	; 255
     16e:	3f 4f       	sbci	r19, 0xFF	; 255
     170:	4f 4f       	sbci	r20, 0xFF	; 255
     172:	5f 4f       	sbci	r21, 0xFF	; 255


	// sample and set the left / right center value for the control stick (average a bunch of samples)

	heading_center = 0;
	for (x = 0; x < 20; x++)
     174:	24 31       	cpi	r18, 0x14	; 20
     176:	31 05       	cpc	r19, r1
     178:	41 05       	cpc	r20, r1
     17a:	51 05       	cpc	r21, r1
     17c:	34 f3       	brlt	.-52     	; 0x14a <get_config_constants+0x7a>
     17e:	20 93 64 01 	sts	0x0164, r18
     182:	30 93 65 01 	sts	0x0165, r19
     186:	40 93 66 01 	sts	0x0166, r20
     18a:	50 93 67 01 	sts	0x0167, r21
	{
		heading_center = heading_center + leftright;               		
		_delay_ms(20);

	}
	heading_center = heading_center / 20;
     18e:	cb 01       	movw	r24, r22
     190:	64 e1       	ldi	r22, 0x14	; 20
     192:	70 e0       	ldi	r23, 0x00	; 0
     194:	0e 94 3f 12 	call	0x247e	; 0x247e <__divmodhi4>
     198:	70 93 0b 01 	sts	0x010B, r23
     19c:	60 93 0a 01 	sts	0x010A, r22


}
     1a0:	df 91       	pop	r29
     1a2:	cf 91       	pop	r28
     1a4:	08 95       	ret

000001a6 <config_mode>:

void config_mode(void)
{
     1a6:	af 92       	push	r10
     1a8:	bf 92       	push	r11
     1aa:	cf 92       	push	r12
     1ac:	df 92       	push	r13
     1ae:	ef 92       	push	r14
     1b0:	ff 92       	push	r15
     1b2:	0f 93       	push	r16
     1b4:	1f 93       	push	r17
     1b6:	cf 93       	push	r28
     1b8:	df 93       	push	r29
	

	//basic tracking adjustment code (is under 50%)
	if (config_mode_throttle_percent < 50)
     1ba:	a0 90 b2 01 	lds	r10, 0x01B2
     1be:	b0 90 b3 01 	lds	r11, 0x01B3
     1c2:	c0 90 b4 01 	lds	r12, 0x01B4
     1c6:	d0 90 b5 01 	lds	r13, 0x01B5
     1ca:	c6 01       	movw	r24, r12
     1cc:	b5 01       	movw	r22, r10
     1ce:	20 e0       	ldi	r18, 0x00	; 0
     1d0:	30 e0       	ldi	r19, 0x00	; 0
     1d2:	48 e4       	ldi	r20, 0x48	; 72
     1d4:	52 e4       	ldi	r21, 0x42	; 66
     1d6:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <__cmpsf2>
     1da:	88 23       	and	r24, r24
     1dc:	0c f0       	brlt	.+2      	; 0x1e0 <config_mode+0x3a>
     1de:	b7 c0       	rjmp	.+366    	; 0x34e <config_mode+0x1a8>
	{
	
		flashy_led = 0;			//flashy LED off unless something is changing
     1e0:	10 92 a3 01 	sts	0x01A3, r1
     1e4:	10 92 a2 01 	sts	0x01A2, r1
		//flashy LED gets turned off to indicate change
		if ( leftright > (heading_center + heading_leftthresh) ) {tracking_comp = tracking_comp + (tracking_comp * 0.003); flashy_led = 1;}
     1e8:	20 91 8e 01 	lds	r18, 0x018E
     1ec:	30 91 8f 01 	lds	r19, 0x018F
     1f0:	40 91 90 01 	lds	r20, 0x0190
     1f4:	50 91 91 01 	lds	r21, 0x0191
     1f8:	c0 91 0a 01 	lds	r28, 0x010A
     1fc:	d0 91 0b 01 	lds	r29, 0x010B
     200:	80 91 0c 01 	lds	r24, 0x010C
     204:	90 91 0d 01 	lds	r25, 0x010D
     208:	8c 0f       	add	r24, r28
     20a:	9d 1f       	adc	r25, r29
     20c:	aa 27       	eor	r26, r26
     20e:	97 fd       	sbrc	r25, 7
     210:	a0 95       	com	r26
     212:	ba 2f       	mov	r27, r26
     214:	82 17       	cp	r24, r18
     216:	93 07       	cpc	r25, r19
     218:	a4 07       	cpc	r26, r20
     21a:	b5 07       	cpc	r27, r21
     21c:	24 f5       	brge	.+72     	; 0x266 <config_mode+0xc0>
     21e:	e0 90 2c 01 	lds	r14, 0x012C
     222:	f0 90 2d 01 	lds	r15, 0x012D
     226:	00 91 2e 01 	lds	r16, 0x012E
     22a:	10 91 2f 01 	lds	r17, 0x012F
     22e:	c8 01       	movw	r24, r16
     230:	b7 01       	movw	r22, r14
     232:	26 ea       	ldi	r18, 0xA6	; 166
     234:	3b e9       	ldi	r19, 0x9B	; 155
     236:	44 e4       	ldi	r20, 0x44	; 68
     238:	5b e3       	ldi	r21, 0x3B	; 59
     23a:	0e 94 52 11 	call	0x22a4	; 0x22a4 <__mulsf3>
     23e:	9b 01       	movw	r18, r22
     240:	ac 01       	movw	r20, r24
     242:	c8 01       	movw	r24, r16
     244:	b7 01       	movw	r22, r14
     246:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <__addsf3>
     24a:	60 93 2c 01 	sts	0x012C, r22
     24e:	70 93 2d 01 	sts	0x012D, r23
     252:	80 93 2e 01 	sts	0x012E, r24
     256:	90 93 2f 01 	sts	0x012F, r25
     25a:	81 e0       	ldi	r24, 0x01	; 1
     25c:	90 e0       	ldi	r25, 0x00	; 0
     25e:	90 93 a3 01 	sts	0x01A3, r25
     262:	80 93 a2 01 	sts	0x01A2, r24
		if ( leftright < (heading_center + heading_rightthresh) ) {tracking_comp = tracking_comp - (tracking_comp * 0.003); flashy_led = 1;}	
     266:	20 91 8e 01 	lds	r18, 0x018E
     26a:	30 91 8f 01 	lds	r19, 0x018F
     26e:	40 91 90 01 	lds	r20, 0x0190
     272:	50 91 91 01 	lds	r21, 0x0191
     276:	80 91 0e 01 	lds	r24, 0x010E
     27a:	90 91 0f 01 	lds	r25, 0x010F
     27e:	c8 0f       	add	r28, r24
     280:	d9 1f       	adc	r29, r25
     282:	ce 01       	movw	r24, r28
     284:	aa 27       	eor	r26, r26
     286:	97 fd       	sbrc	r25, 7
     288:	a0 95       	com	r26
     28a:	ba 2f       	mov	r27, r26
     28c:	28 17       	cp	r18, r24
     28e:	39 07       	cpc	r19, r25
     290:	4a 07       	cpc	r20, r26
     292:	5b 07       	cpc	r21, r27
     294:	24 f5       	brge	.+72     	; 0x2de <config_mode+0x138>
     296:	e0 90 2c 01 	lds	r14, 0x012C
     29a:	f0 90 2d 01 	lds	r15, 0x012D
     29e:	00 91 2e 01 	lds	r16, 0x012E
     2a2:	10 91 2f 01 	lds	r17, 0x012F
     2a6:	c8 01       	movw	r24, r16
     2a8:	b7 01       	movw	r22, r14
     2aa:	26 ea       	ldi	r18, 0xA6	; 166
     2ac:	3b e9       	ldi	r19, 0x9B	; 155
     2ae:	44 e4       	ldi	r20, 0x44	; 68
     2b0:	5b eb       	ldi	r21, 0xBB	; 187
     2b2:	0e 94 52 11 	call	0x22a4	; 0x22a4 <__mulsf3>
     2b6:	9b 01       	movw	r18, r22
     2b8:	ac 01       	movw	r20, r24
     2ba:	c8 01       	movw	r24, r16
     2bc:	b7 01       	movw	r22, r14
     2be:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <__addsf3>
     2c2:	60 93 2c 01 	sts	0x012C, r22
     2c6:	70 93 2d 01 	sts	0x012D, r23
     2ca:	80 93 2e 01 	sts	0x012E, r24
     2ce:	90 93 2f 01 	sts	0x012F, r25
     2d2:	81 e0       	ldi	r24, 0x01	; 1
     2d4:	90 e0       	ldi	r25, 0x00	; 0
     2d6:	90 93 a3 01 	sts	0x01A3, r25
     2da:	80 93 a2 01 	sts	0x01A2, r24

		if (tracking_comp < 0.1) tracking_comp = 0.1;
     2de:	60 91 2c 01 	lds	r22, 0x012C
     2e2:	70 91 2d 01 	lds	r23, 0x012D
     2e6:	80 91 2e 01 	lds	r24, 0x012E
     2ea:	90 91 2f 01 	lds	r25, 0x012F
     2ee:	2d ec       	ldi	r18, 0xCD	; 205
     2f0:	3c ec       	ldi	r19, 0xCC	; 204
     2f2:	4c ec       	ldi	r20, 0xCC	; 204
     2f4:	5d e3       	ldi	r21, 0x3D	; 61
     2f6:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <__cmpsf2>
     2fa:	88 23       	and	r24, r24
     2fc:	64 f4       	brge	.+24     	; 0x316 <config_mode+0x170>
     2fe:	8d ec       	ldi	r24, 0xCD	; 205
     300:	9c ec       	ldi	r25, 0xCC	; 204
     302:	ac ec       	ldi	r26, 0xCC	; 204
     304:	bd e3       	ldi	r27, 0x3D	; 61
     306:	80 93 2c 01 	sts	0x012C, r24
     30a:	90 93 2d 01 	sts	0x012D, r25
     30e:	a0 93 2e 01 	sts	0x012E, r26
     312:	b0 93 2f 01 	sts	0x012F, r27
		if (tracking_comp > 10) tracking_comp = 10;
     316:	60 91 2c 01 	lds	r22, 0x012C
     31a:	70 91 2d 01 	lds	r23, 0x012D
     31e:	80 91 2e 01 	lds	r24, 0x012E
     322:	90 91 2f 01 	lds	r25, 0x012F
     326:	20 e0       	ldi	r18, 0x00	; 0
     328:	30 e0       	ldi	r19, 0x00	; 0
     32a:	40 e2       	ldi	r20, 0x20	; 32
     32c:	51 e4       	ldi	r21, 0x41	; 65
     32e:	0e 94 4e 11 	call	0x229c	; 0x229c <__gesf2>
     332:	18 16       	cp	r1, r24
     334:	64 f4       	brge	.+24     	; 0x34e <config_mode+0x1a8>
     336:	80 e0       	ldi	r24, 0x00	; 0
     338:	90 e0       	ldi	r25, 0x00	; 0
     33a:	a0 e2       	ldi	r26, 0x20	; 32
     33c:	b1 e4       	ldi	r27, 0x41	; 65
     33e:	80 93 2c 01 	sts	0x012C, r24
     342:	90 93 2d 01 	sts	0x012D, r25
     346:	a0 93 2e 01 	sts	0x012E, r26
     34a:	b0 93 2f 01 	sts	0x012F, r27
	}	


	//heading adjustment code (when throttle is between 50% and 90%)
	if (config_mode_throttle_percent >= 50 && config_mode_throttle_percent < 90)
     34e:	c6 01       	movw	r24, r12
     350:	b5 01       	movw	r22, r10
     352:	20 e0       	ldi	r18, 0x00	; 0
     354:	30 e0       	ldi	r19, 0x00	; 0
     356:	48 e4       	ldi	r20, 0x48	; 72
     358:	52 e4       	ldi	r21, 0x42	; 66
     35a:	0e 94 4e 11 	call	0x229c	; 0x229c <__gesf2>
     35e:	88 23       	and	r24, r24
     360:	0c f4       	brge	.+2      	; 0x364 <config_mode+0x1be>
     362:	b0 c0       	rjmp	.+352    	; 0x4c4 <config_mode+0x31e>
     364:	c6 01       	movw	r24, r12
     366:	b5 01       	movw	r22, r10
     368:	20 e0       	ldi	r18, 0x00	; 0
     36a:	30 e0       	ldi	r19, 0x00	; 0
     36c:	44 eb       	ldi	r20, 0xB4	; 180
     36e:	52 e4       	ldi	r21, 0x42	; 66
     370:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <__cmpsf2>
     374:	88 23       	and	r24, r24
     376:	0c f0       	brlt	.+2      	; 0x37a <config_mode+0x1d4>
     378:	a5 c0       	rjmp	.+330    	; 0x4c4 <config_mode+0x31e>
	{
		
		flashy_led = 1;				//pulse the LED to indicate we're in heading adjustment
     37a:	81 e0       	ldi	r24, 0x01	; 1
     37c:	90 e0       	ldi	r25, 0x00	; 0
     37e:	90 93 a3 01 	sts	0x01A3, r25
     382:	80 93 a2 01 	sts	0x01A2, r24
		if ( leftright > (heading_center + heading_leftthresh) ) {led_adjust = led_adjust + 1; flashy_led = 0;}   //flashing gets turned back off to indicate change
     386:	20 91 8e 01 	lds	r18, 0x018E
     38a:	30 91 8f 01 	lds	r19, 0x018F
     38e:	40 91 90 01 	lds	r20, 0x0190
     392:	50 91 91 01 	lds	r21, 0x0191
     396:	c0 91 0a 01 	lds	r28, 0x010A
     39a:	d0 91 0b 01 	lds	r29, 0x010B
     39e:	80 91 0c 01 	lds	r24, 0x010C
     3a2:	90 91 0d 01 	lds	r25, 0x010D
     3a6:	8c 0f       	add	r24, r28
     3a8:	9d 1f       	adc	r25, r29
     3aa:	aa 27       	eor	r26, r26
     3ac:	97 fd       	sbrc	r25, 7
     3ae:	a0 95       	com	r26
     3b0:	ba 2f       	mov	r27, r26
     3b2:	82 17       	cp	r24, r18
     3b4:	93 07       	cpc	r25, r19
     3b6:	a4 07       	cpc	r26, r20
     3b8:	b5 07       	cpc	r27, r21
     3ba:	d4 f4       	brge	.+52     	; 0x3f0 <config_mode+0x24a>
     3bc:	60 91 30 01 	lds	r22, 0x0130
     3c0:	70 91 31 01 	lds	r23, 0x0131
     3c4:	80 91 32 01 	lds	r24, 0x0132
     3c8:	90 91 33 01 	lds	r25, 0x0133
     3cc:	20 e0       	ldi	r18, 0x00	; 0
     3ce:	30 e0       	ldi	r19, 0x00	; 0
     3d0:	40 e8       	ldi	r20, 0x80	; 128
     3d2:	5f e3       	ldi	r21, 0x3F	; 63
     3d4:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <__addsf3>
     3d8:	60 93 30 01 	sts	0x0130, r22
     3dc:	70 93 31 01 	sts	0x0131, r23
     3e0:	80 93 32 01 	sts	0x0132, r24
     3e4:	90 93 33 01 	sts	0x0133, r25
     3e8:	10 92 a3 01 	sts	0x01A3, r1
     3ec:	10 92 a2 01 	sts	0x01A2, r1
		if ( leftright < (heading_center + heading_rightthresh) ) {led_adjust = led_adjust - 1; flashy_led = 0;}
     3f0:	20 91 8e 01 	lds	r18, 0x018E
     3f4:	30 91 8f 01 	lds	r19, 0x018F
     3f8:	40 91 90 01 	lds	r20, 0x0190
     3fc:	50 91 91 01 	lds	r21, 0x0191
     400:	80 91 0e 01 	lds	r24, 0x010E
     404:	90 91 0f 01 	lds	r25, 0x010F
     408:	c8 0f       	add	r28, r24
     40a:	d9 1f       	adc	r29, r25
     40c:	ce 01       	movw	r24, r28
     40e:	aa 27       	eor	r26, r26
     410:	97 fd       	sbrc	r25, 7
     412:	a0 95       	com	r26
     414:	ba 2f       	mov	r27, r26
     416:	28 17       	cp	r18, r24
     418:	39 07       	cpc	r19, r25
     41a:	4a 07       	cpc	r20, r26
     41c:	5b 07       	cpc	r21, r27
     41e:	d4 f4       	brge	.+52     	; 0x454 <config_mode+0x2ae>
     420:	60 91 30 01 	lds	r22, 0x0130
     424:	70 91 31 01 	lds	r23, 0x0131
     428:	80 91 32 01 	lds	r24, 0x0132
     42c:	90 91 33 01 	lds	r25, 0x0133
     430:	20 e0       	ldi	r18, 0x00	; 0
     432:	30 e0       	ldi	r19, 0x00	; 0
     434:	40 e8       	ldi	r20, 0x80	; 128
     436:	5f e3       	ldi	r21, 0x3F	; 63
     438:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <__subsf3>
     43c:	60 93 30 01 	sts	0x0130, r22
     440:	70 93 31 01 	sts	0x0131, r23
     444:	80 93 32 01 	sts	0x0132, r24
     448:	90 93 33 01 	sts	0x0133, r25
     44c:	10 92 a3 01 	sts	0x01A3, r1
     450:	10 92 a2 01 	sts	0x01A2, r1

		if (led_adjust < 0) led_adjust = 100;
     454:	60 91 30 01 	lds	r22, 0x0130
     458:	70 91 31 01 	lds	r23, 0x0131
     45c:	80 91 32 01 	lds	r24, 0x0132
     460:	90 91 33 01 	lds	r25, 0x0133
     464:	20 e0       	ldi	r18, 0x00	; 0
     466:	30 e0       	ldi	r19, 0x00	; 0
     468:	40 e0       	ldi	r20, 0x00	; 0
     46a:	50 e0       	ldi	r21, 0x00	; 0
     46c:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <__cmpsf2>
     470:	88 23       	and	r24, r24
     472:	64 f4       	brge	.+24     	; 0x48c <config_mode+0x2e6>
     474:	80 e0       	ldi	r24, 0x00	; 0
     476:	90 e0       	ldi	r25, 0x00	; 0
     478:	a8 ec       	ldi	r26, 0xC8	; 200
     47a:	b2 e4       	ldi	r27, 0x42	; 66
     47c:	80 93 30 01 	sts	0x0130, r24
     480:	90 93 31 01 	sts	0x0131, r25
     484:	a0 93 32 01 	sts	0x0132, r26
     488:	b0 93 33 01 	sts	0x0133, r27
		if (led_adjust > 100) led_adjust = 0;
     48c:	60 91 30 01 	lds	r22, 0x0130
     490:	70 91 31 01 	lds	r23, 0x0131
     494:	80 91 32 01 	lds	r24, 0x0132
     498:	90 91 33 01 	lds	r25, 0x0133
     49c:	20 e0       	ldi	r18, 0x00	; 0
     49e:	30 e0       	ldi	r19, 0x00	; 0
     4a0:	48 ec       	ldi	r20, 0xC8	; 200
     4a2:	52 e4       	ldi	r21, 0x42	; 66
     4a4:	0e 94 4e 11 	call	0x229c	; 0x229c <__gesf2>
     4a8:	18 16       	cp	r1, r24
     4aa:	64 f4       	brge	.+24     	; 0x4c4 <config_mode+0x31e>
     4ac:	80 e0       	ldi	r24, 0x00	; 0
     4ae:	90 e0       	ldi	r25, 0x00	; 0
     4b0:	a0 e0       	ldi	r26, 0x00	; 0
     4b2:	b0 e0       	ldi	r27, 0x00	; 0
     4b4:	80 93 30 01 	sts	0x0130, r24
     4b8:	90 93 31 01 	sts	0x0131, r25
     4bc:	a0 93 32 01 	sts	0x0132, r26
     4c0:	b0 93 33 01 	sts	0x0133, r27
	}	
	
	//if we're above 90% throttle - the bot is effectively in normal drive mode - with throttle locked at 50%


}
     4c4:	df 91       	pop	r29
     4c6:	cf 91       	pop	r28
     4c8:	1f 91       	pop	r17
     4ca:	0f 91       	pop	r16
     4cc:	ff 90       	pop	r15
     4ce:	ef 90       	pop	r14
     4d0:	df 90       	pop	r13
     4d2:	cf 90       	pop	r12
     4d4:	bf 90       	pop	r11
     4d6:	af 90       	pop	r10
     4d8:	08 95       	ret

000004da <setup>:
void adc_init(void)

{
 
  	// Free running Mode
	ADCSRB = 0x00;
     4da:	10 92 7b 00 	sts	0x007B, r1

   // Set ADCSRA Register in ATMega168
   ADCSRA = (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1);
     4de:	86 e8       	ldi	r24, 0x86	; 134
     4e0:	80 93 7a 00 	sts	0x007A, r24

   // Set ADMUX Register in ATMega168
   ADMUX=ADC_PORT_FOR_ACCEL;	
     4e4:	84 e0       	ldi	r24, 0x04	; 4
     4e6:	80 93 7c 00 	sts	0x007C, r24

{

	adc_init();		//init the ADC...

	set_throttle_pin_as_input();
     4ea:	20 98       	cbi	0x04, 0	; 4
	set_leftright_pin_as_input();  
     4ec:	21 98       	cbi	0x04, 1	; 4
	set_forwardback_pin_as_input();
     4ee:	22 98       	cbi	0x04, 2	; 4
  
	set_accel_data_pin_as_input();
     4f0:	3c 98       	cbi	0x07, 4	; 7
	
	set_accelpower_pin_as_output();
     4f2:	50 9a       	sbi	0x0a, 0	; 10
	set_accelpower_pin_on();								//turn on power for accel (accel is connected to chip for power)
     4f4:	58 9a       	sbi	0x0b, 0	; 11


	
	set_led_pin_as_output();
     4f6:	55 9a       	sbi	0x0a, 5	; 10

	set_motor1_pin_as_output();
     4f8:	52 9a       	sbi	0x0a, 2	; 10
	set_motor2_pin_as_output();
     4fa:	54 9a       	sbi	0x0a, 4	; 10
	
	set_led_on();						                    //turn on signal LED before timers so it comes on immediately
     4fc:	5d 9a       	sbi	0x0b, 5	; 11
	

	//enable pin change interrupt - any changes on PORTB trigger interrupt
	PCMSK0 = 0xFF;
     4fe:	8f ef       	ldi	r24, 0xFF	; 255
     500:	80 93 6b 00 	sts	0x006B, r24
	PCICR = 1<<PCIE0; 
     504:	81 e0       	ldi	r24, 0x01	; 1
     506:	80 93 68 00 	sts	0x0068, r24


void SetupTimer1(void)
{

	TCCR1A = 0;                               //mode = 0
     50a:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0<<CS12 | 1<<CS11 | 1<<CS10;    //prescaler = 64
     50e:	83 e0       	ldi	r24, 0x03	; 3
     510:	80 93 81 00 	sts	0x0081, r24
}


void motors_off(void)
{
	set_motor1_off();
     514:	5a 98       	cbi	0x0b, 2	; 11
	set_motor2_off();
     516:	5c 98       	cbi	0x0b, 4	; 11
     518:	21 e0       	ldi	r18, 0x01	; 1
     51a:	30 e0       	ldi	r19, 0x00	; 0
     51c:	40 e0       	ldi	r20, 0x00	; 0
     51e:	50 e0       	ldi	r21, 0x00	; 0


	//flash LED on boot	(fast - so visible if spinning)
	for (x = 1; x <= 250; x++)
	{
		toggle_led();
     520:	e0 e2       	ldi	r30, 0x20	; 32
     522:	68 e8       	ldi	r22, 0x88	; 136
     524:	73 e1       	ldi	r23, 0x13	; 19
     526:	0a c0       	rjmp	.+20     	; 0x53c <__stack+0x3d>
     528:	8b b1       	in	r24, 0x0b	; 11
     52a:	8e 27       	eor	r24, r30
     52c:	8b b9       	out	0x0b, r24	; 11
     52e:	cb 01       	movw	r24, r22
     530:	01 97       	sbiw	r24, 0x01	; 1
     532:	f1 f7       	brne	.-4      	; 0x530 <__stack+0x31>
     534:	2f 5f       	subi	r18, 0xFF	; 255
     536:	3f 4f       	sbci	r19, 0xFF	; 255
     538:	4f 4f       	sbci	r20, 0xFF	; 255
     53a:	5f 4f       	sbci	r21, 0xFF	; 255

	motors_off();   //make sure those motors are off...


	//flash LED on boot	(fast - so visible if spinning)
	for (x = 1; x <= 250; x++)
     53c:	2b 3f       	cpi	r18, 0xFB	; 251
     53e:	31 05       	cpc	r19, r1
     540:	41 05       	cpc	r20, r1
     542:	51 05       	cpc	r21, r1
     544:	8c f3       	brlt	.-30     	; 0x528 <__stack+0x29>
     546:	21 e0       	ldi	r18, 0x01	; 1
     548:	30 e0       	ldi	r19, 0x00	; 0
     54a:	40 e0       	ldi	r20, 0x00	; 0
     54c:	50 e0       	ldi	r21, 0x00	; 0


	//flash LED on boot (slower)
	for (x = 1; x <= 15; x++)
	{
		toggle_led();
     54e:	a0 e2       	ldi	r26, 0x20	; 32
     550:	64 ef       	ldi	r22, 0xF4	; 244
     552:	71 e0       	ldi	r23, 0x01	; 1
     554:	0e c0       	rjmp	.+28     	; 0x572 <__stack+0x73>
     556:	8b b1       	in	r24, 0x0b	; 11
     558:	8a 27       	eor	r24, r26
     55a:	8b b9       	out	0x0b, r24	; 11
     55c:	86 e9       	ldi	r24, 0x96	; 150
     55e:	90 e0       	ldi	r25, 0x00	; 0
     560:	fb 01       	movw	r30, r22
     562:	31 97       	sbiw	r30, 0x01	; 1
     564:	f1 f7       	brne	.-4      	; 0x562 <__stack+0x63>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     566:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     568:	d9 f7       	brne	.-10     	; 0x560 <__stack+0x61>
     56a:	2f 5f       	subi	r18, 0xFF	; 255
     56c:	3f 4f       	sbci	r19, 0xFF	; 255
     56e:	4f 4f       	sbci	r20, 0xFF	; 255
     570:	5f 4f       	sbci	r21, 0xFF	; 255
		_delay_ms(1);
	}


	//flash LED on boot (slower)
	for (x = 1; x <= 15; x++)
     572:	20 31       	cpi	r18, 0x10	; 16
     574:	31 05       	cpc	r19, r1
     576:	41 05       	cpc	r20, r1
     578:	51 05       	cpc	r21, r1
     57a:	6c f3       	brlt	.-38     	; 0x556 <__stack+0x57>
     57c:	20 93 64 01 	sts	0x0164, r18
     580:	30 93 65 01 	sts	0x0165, r19
     584:	40 93 66 01 	sts	0x0166, r20
     588:	50 93 67 01 	sts	0x0167, r21
	{
		toggle_led();
		_delay_ms(15);
	}

	throttle = 0;   //make sure throttle is off at boot
     58c:	10 92 86 01 	sts	0x0186, r1
     590:	10 92 87 01 	sts	0x0187, r1
     594:	10 92 88 01 	sts	0x0188, r1
     598:	10 92 89 01 	sts	0x0189, r1


}
     59c:	08 95       	ret

0000059e <do_spin_180>:
}


	
void do_spin_180(int spin_cycle)
{	
     59e:	2f 92       	push	r2
     5a0:	3f 92       	push	r3
     5a2:	4f 92       	push	r4
     5a4:	5f 92       	push	r5
     5a6:	6f 92       	push	r6
     5a8:	7f 92       	push	r7
     5aa:	8f 92       	push	r8
     5ac:	9f 92       	push	r9
     5ae:	af 92       	push	r10
     5b0:	bf 92       	push	r11
     5b2:	cf 92       	push	r12
     5b4:	df 92       	push	r13
     5b6:	ef 92       	push	r14
     5b8:	ff 92       	push	r15
     5ba:	0f 93       	push	r16
     5bc:	1f 93       	push	r17
     5be:	df 93       	push	r29
     5c0:	cf 93       	push	r28
     5c2:	cd b7       	in	r28, 0x3d	; 61
     5c4:	de b7       	in	r29, 0x3e	; 62
     5c6:	a2 97       	sbiw	r28, 0x22	; 34
     5c8:	0f b6       	in	r0, 0x3f	; 63
     5ca:	f8 94       	cli
     5cc:	de bf       	out	0x3e, r29	; 62
     5ce:	0f be       	out	0x3f, r0	; 63
     5d0:	cd bf       	out	0x3d, r28	; 61
     5d2:	5c 01       	movw	r10, r24

	while (TCNT1 < half_spin_time)
     5d4:	20 91 8a 01 	lds	r18, 0x018A
     5d8:	30 91 8b 01 	lds	r19, 0x018B
     5dc:	40 91 8c 01 	lds	r20, 0x018C
     5e0:	50 91 8d 01 	lds	r21, 0x018D
     5e4:	29 83       	std	Y+1, r18	; 0x01
     5e6:	3a 83       	std	Y+2, r19	; 0x02
     5e8:	4b 83       	std	Y+3, r20	; 0x03
     5ea:	5c 83       	std	Y+4, r21	; 0x04
	{
	
		if (TCNT1 < begin_brake) motors_left();				//full power if we haven't entered braking yet
     5ec:	80 91 c2 01 	lds	r24, 0x01C2
     5f0:	90 91 c3 01 	lds	r25, 0x01C3
     5f4:	a0 91 c4 01 	lds	r26, 0x01C4
     5f8:	b0 91 c5 01 	lds	r27, 0x01C5
     5fc:	8d 8f       	std	Y+29, r24	; 0x1d
     5fe:	9e 8f       	std	Y+30, r25	; 0x1e
     600:	af 8f       	std	Y+31, r26	; 0x1f
     602:	b8 a3       	std	Y+32, r27	; 0x20
		if (TCNT1 > end_brake) motors_left();					//full power if we're after braking
     604:	20 91 92 01 	lds	r18, 0x0192
     608:	30 91 93 01 	lds	r19, 0x0193
     60c:	40 91 94 01 	lds	r20, 0x0194
     610:	50 91 95 01 	lds	r21, 0x0195
     614:	29 8f       	std	Y+25, r18	; 0x19
     616:	3a 8f       	std	Y+26, r19	; 0x1a
     618:	4b 8f       	std	Y+27, r20	; 0x1b
     61a:	5c 8f       	std	Y+28, r21	; 0x1c

		led_ref = TCNT1 + led_hold_over;						//provides continuous LED tracking between the two do_spin loops
     61c:	80 91 68 01 	lds	r24, 0x0168
     620:	90 91 69 01 	lds	r25, 0x0169
     624:	a0 91 6a 01 	lds	r26, 0x016A
     628:	b0 91 6b 01 	lds	r27, 0x016B
     62c:	8d 8b       	std	Y+21, r24	; 0x15
     62e:	9e 8b       	std	Y+22, r25	; 0x16
     630:	af 8b       	std	Y+23, r26	; 0x17
     632:	b8 8f       	std	Y+24, r27	; 0x18

		if ( TCNT1 > begin_brake && TCNT1 < end_brake )         //switch to single motor as soon as entering braking cycle
		{
			//if sitting still
			if ( forward == 0 && backward == 0 )
     634:	a0 91 a0 01 	lds	r26, 0x01A0
     638:	b0 91 a1 01 	lds	r27, 0x01A1
     63c:	bc 8b       	std	Y+20, r27	; 0x14
     63e:	ab 8b       	std	Y+19, r26	; 0x13
     640:	e0 91 b0 01 	lds	r30, 0x01B0
     644:	f0 91 b1 01 	lds	r31, 0x01B1
     648:	fa 8b       	std	Y+18, r31	; 0x12
     64a:	e9 8b       	std	Y+17, r30	; 0x11
			{
				if ( alternate_motor_cycle == 0 )  //alternates which motor is used each cycle if sitting still
     64c:	20 91 3e 01 	lds	r18, 0x013E
     650:	30 91 3f 01 	lds	r19, 0x013F
     654:	38 8b       	std	Y+16, r19	; 0x10
     656:	2f 87       	std	Y+15, r18	; 0x0f
				
		}

		if ( TCNT1 > end_brake ) motors_left();                 //if we hit end of brake cycle - go to full power

		if ( TCNT1 < power_kill_part1 ) motors_off();            //if throttle is less that 100% - kill power at appropriate time
     658:	80 91 82 01 	lds	r24, 0x0182
     65c:	90 91 83 01 	lds	r25, 0x0183
     660:	a0 91 84 01 	lds	r26, 0x0184
     664:	b0 91 85 01 	lds	r27, 0x0185
     668:	8b 87       	std	Y+11, r24	; 0x0b
     66a:	9c 87       	std	Y+12, r25	; 0x0c
     66c:	ad 87       	std	Y+13, r26	; 0x0d
     66e:	be 87       	std	Y+14, r27	; 0x0e
		if ( TCNT1 > power_kill_part2 ) motors_off();            //if throttle is less that 100% - kill power at appropriate time
     670:	20 91 7a 01 	lds	r18, 0x017A
     674:	30 91 7b 01 	lds	r19, 0x017B
     678:	40 91 7c 01 	lds	r20, 0x017C
     67c:	50 91 7d 01 	lds	r21, 0x017D
     680:	2f 83       	std	Y+7, r18	; 0x07
     682:	38 87       	std	Y+8, r19	; 0x08
     684:	49 87       	std	Y+9, r20	; 0x09
     686:	5a 87       	std	Y+10, r21	; 0x0a

		
		//following code handles turning on and off LED (little confusing)
		
		if (led_on > led_off)
     688:	20 90 96 01 	lds	r2, 0x0196
     68c:	30 90 97 01 	lds	r3, 0x0197
     690:	40 90 98 01 	lds	r4, 0x0198
     694:	50 90 99 01 	lds	r5, 0x0199
     698:	60 90 b8 01 	lds	r6, 0x01B8
     69c:	70 90 b9 01 	lds	r7, 0x01B9
     6a0:	80 90 ba 01 	lds	r8, 0x01BA
     6a4:	90 90 bb 01 	lds	r9, 0x01BB
	
	
		if ( led_is_on_now == 1 )
		{
			//flash the LED if we're in flashy mode - otherwise it's just on
			if ( flashy_led == 1 )
     6a8:	40 91 a2 01 	lds	r20, 0x01A2
     6ac:	50 91 a3 01 	lds	r21, 0x01A3
     6b0:	5e 83       	std	Y+6, r21	; 0x06
     6b2:	4d 83       	std	Y+5, r20	; 0x05
     6b4:	c0 90 72 01 	lds	r12, 0x0172
     6b8:	d0 90 73 01 	lds	r13, 0x0173
     6bc:	e0 90 74 01 	lds	r14, 0x0174
     6c0:	f0 90 75 01 	lds	r15, 0x0175
     6c4:	80 91 70 01 	lds	r24, 0x0170
     6c8:	90 91 71 01 	lds	r25, 0x0171
     6cc:	9a a3       	std	Y+34, r25	; 0x22
     6ce:	89 a3       	std	Y+33, r24	; 0x21
		if ( TCNT1 > power_kill_part2 ) motors_off();            //if throttle is less that 100% - kill power at appropriate time

		
		//following code handles turning on and off LED (little confusing)
		
		if (led_on > led_off)
     6d0:	01 e0       	ldi	r16, 0x01	; 1
     6d2:	31 c1       	rjmp	.+610    	; 0x936 <do_spin_180+0x398>
{	

	while (TCNT1 < half_spin_time)
	{
	
		if (TCNT1 < begin_brake) motors_left();				//full power if we haven't entered braking yet
     6d4:	60 91 84 00 	lds	r22, 0x0084
     6d8:	70 91 85 00 	lds	r23, 0x0085
     6dc:	80 e0       	ldi	r24, 0x00	; 0
     6de:	90 e0       	ldi	r25, 0x00	; 0
     6e0:	0e 94 9c 10 	call	0x2138	; 0x2138 <__floatunsisf>
     6e4:	2d 8d       	ldd	r18, Y+29	; 0x1d
     6e6:	3e 8d       	ldd	r19, Y+30	; 0x1e
     6e8:	4f 8d       	ldd	r20, Y+31	; 0x1f
     6ea:	58 a1       	ldd	r21, Y+32	; 0x20
     6ec:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <__cmpsf2>
     6f0:	88 23       	and	r24, r24
     6f2:	14 f4       	brge	.+4      	; 0x6f8 <do_spin_180+0x15a>
}


void motors_left(void)
{
	set_motor1_on();
     6f4:	5a 9a       	sbi	0x0b, 2	; 11
	set_motor2_on();
     6f6:	5c 9a       	sbi	0x0b, 4	; 11

	while (TCNT1 < half_spin_time)
	{
	
		if (TCNT1 < begin_brake) motors_left();				//full power if we haven't entered braking yet
		if (TCNT1 > end_brake) motors_left();					//full power if we're after braking
     6f8:	60 91 84 00 	lds	r22, 0x0084
     6fc:	70 91 85 00 	lds	r23, 0x0085
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	0e 94 9c 10 	call	0x2138	; 0x2138 <__floatunsisf>
     708:	29 8d       	ldd	r18, Y+25	; 0x19
     70a:	3a 8d       	ldd	r19, Y+26	; 0x1a
     70c:	4b 8d       	ldd	r20, Y+27	; 0x1b
     70e:	5c 8d       	ldd	r21, Y+28	; 0x1c
     710:	0e 94 4e 11 	call	0x229c	; 0x229c <__gesf2>
     714:	18 16       	cp	r1, r24
     716:	14 f4       	brge	.+4      	; 0x71c <do_spin_180+0x17e>
}


void motors_left(void)
{
	set_motor1_on();
     718:	5a 9a       	sbi	0x0b, 2	; 11
	set_motor2_on();
     71a:	5c 9a       	sbi	0x0b, 4	; 11
	{
	
		if (TCNT1 < begin_brake) motors_left();				//full power if we haven't entered braking yet
		if (TCNT1 > end_brake) motors_left();					//full power if we're after braking

		led_ref = TCNT1 + led_hold_over;						//provides continuous LED tracking between the two do_spin loops
     71c:	60 91 84 00 	lds	r22, 0x0084
     720:	70 91 85 00 	lds	r23, 0x0085
     724:	80 e0       	ldi	r24, 0x00	; 0
     726:	90 e0       	ldi	r25, 0x00	; 0
     728:	2d 89       	ldd	r18, Y+21	; 0x15
     72a:	3e 89       	ldd	r19, Y+22	; 0x16
     72c:	4f 89       	ldd	r20, Y+23	; 0x17
     72e:	58 8d       	ldd	r21, Y+24	; 0x18
     730:	62 0f       	add	r22, r18
     732:	73 1f       	adc	r23, r19
     734:	84 1f       	adc	r24, r20
     736:	95 1f       	adc	r25, r21
     738:	0e 94 9e 10 	call	0x213c	; 0x213c <__floatsisf>
     73c:	6b 01       	movw	r12, r22
     73e:	7c 01       	movw	r14, r24

		if ( TCNT1 > begin_brake && TCNT1 < end_brake )         //switch to single motor as soon as entering braking cycle
     740:	60 91 84 00 	lds	r22, 0x0084
     744:	70 91 85 00 	lds	r23, 0x0085
     748:	80 e0       	ldi	r24, 0x00	; 0
     74a:	90 e0       	ldi	r25, 0x00	; 0
     74c:	0e 94 9c 10 	call	0x2138	; 0x2138 <__floatunsisf>
     750:	2d 8d       	ldd	r18, Y+29	; 0x1d
     752:	3e 8d       	ldd	r19, Y+30	; 0x1e
     754:	4f 8d       	ldd	r20, Y+31	; 0x1f
     756:	58 a1       	ldd	r21, Y+32	; 0x20
     758:	0e 94 4e 11 	call	0x229c	; 0x229c <__gesf2>
     75c:	18 16       	cp	r1, r24
     75e:	0c f0       	brlt	.+2      	; 0x762 <do_spin_180+0x1c4>
     760:	56 c0       	rjmp	.+172    	; 0x80e <do_spin_180+0x270>
     762:	60 91 84 00 	lds	r22, 0x0084
     766:	70 91 85 00 	lds	r23, 0x0085
     76a:	80 e0       	ldi	r24, 0x00	; 0
     76c:	90 e0       	ldi	r25, 0x00	; 0
     76e:	0e 94 9c 10 	call	0x2138	; 0x2138 <__floatunsisf>
     772:	29 8d       	ldd	r18, Y+25	; 0x19
     774:	3a 8d       	ldd	r19, Y+26	; 0x1a
     776:	4b 8d       	ldd	r20, Y+27	; 0x1b
     778:	5c 8d       	ldd	r21, Y+28	; 0x1c
     77a:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <__cmpsf2>
     77e:	88 23       	and	r24, r24
     780:	0c f0       	brlt	.+2      	; 0x784 <do_spin_180+0x1e6>
     782:	45 c0       	rjmp	.+138    	; 0x80e <do_spin_180+0x270>
		{
			//if sitting still
			if ( forward == 0 && backward == 0 )
     784:	4b 89       	ldd	r20, Y+19	; 0x13
     786:	5c 89       	ldd	r21, Y+20	; 0x14
     788:	45 2b       	or	r20, r21
     78a:	f9 f4       	brne	.+62     	; 0x7ca <do_spin_180+0x22c>
     78c:	89 89       	ldd	r24, Y+17	; 0x11
     78e:	9a 89       	ldd	r25, Y+18	; 0x12
     790:	89 2b       	or	r24, r25
     792:	61 f5       	brne	.+88     	; 0x7ec <do_spin_180+0x24e>
			{
				if ( alternate_motor_cycle == 0 )  //alternates which motor is used each cycle if sitting still
     794:	af 85       	ldd	r26, Y+15	; 0x0f
     796:	b8 89       	ldd	r27, Y+16	; 0x10
     798:	ab 2b       	or	r26, r27
     79a:	49 f4       	brne	.+18     	; 0x7ae <do_spin_180+0x210>
				{	
					if (spin_cycle == 1) motor1_on();
     79c:	b1 e0       	ldi	r27, 0x01	; 1
     79e:	ab 16       	cp	r10, r27
     7a0:	b1 04       	cpc	r11, r1
     7a2:	d9 f0       	breq	.+54     	; 0x7da <do_spin_180+0x23c>
					if (spin_cycle == 2) motor2_on();
     7a4:	e2 e0       	ldi	r30, 0x02	; 2
     7a6:	ae 16       	cp	r10, r30
     7a8:	b1 04       	cpc	r11, r1
     7aa:	01 f5       	brne	.+64     	; 0x7ec <do_spin_180+0x24e>
     7ac:	1d c0       	rjmp	.+58     	; 0x7e8 <do_spin_180+0x24a>
				}

				if ( alternate_motor_cycle == 1 )
     7ae:	2f 85       	ldd	r18, Y+15	; 0x0f
     7b0:	38 89       	ldd	r19, Y+16	; 0x10
     7b2:	21 30       	cpi	r18, 0x01	; 1
     7b4:	31 05       	cpc	r19, r1
     7b6:	d1 f4       	brne	.+52     	; 0x7ec <do_spin_180+0x24e>
				{	
					if (spin_cycle == 1) motor2_on();
     7b8:	31 e0       	ldi	r19, 0x01	; 1
     7ba:	a3 16       	cp	r10, r19
     7bc:	b1 04       	cpc	r11, r1
     7be:	a1 f0       	breq	.+40     	; 0x7e8 <do_spin_180+0x24a>
					if (spin_cycle == 2) motor1_on();
     7c0:	42 e0       	ldi	r20, 0x02	; 2
     7c2:	a4 16       	cp	r10, r20
     7c4:	b1 04       	cpc	r11, r1
     7c6:	91 f4       	brne	.+36     	; 0x7ec <do_spin_180+0x24e>
     7c8:	08 c0       	rjmp	.+16     	; 0x7da <do_spin_180+0x23c>
				}

			}

			//if ( going forward / back set motors appropriately (this is "where it happens")
			if ( forward == 1)
     7ca:	8b 89       	ldd	r24, Y+19	; 0x13
     7cc:	9c 89       	ldd	r25, Y+20	; 0x14
     7ce:	01 97       	sbiw	r24, 0x01	; 1
     7d0:	69 f4       	brne	.+26     	; 0x7ec <do_spin_180+0x24e>
			{	
				if (spin_cycle == 1) motor1_on();
     7d2:	91 e0       	ldi	r25, 0x01	; 1
     7d4:	a9 16       	cp	r10, r25
     7d6:	b1 04       	cpc	r11, r1
     7d8:	19 f4       	brne	.+6      	; 0x7e0 <do_spin_180+0x242>
}


void motor1_on(void)
{
	set_motor1_on();
     7da:	5a 9a       	sbi	0x0b, 2	; 11
	set_motor2_off();
     7dc:	5c 98       	cbi	0x0b, 4	; 11
     7de:	06 c0       	rjmp	.+12     	; 0x7ec <do_spin_180+0x24e>

			//if ( going forward / back set motors appropriately (this is "where it happens")
			if ( forward == 1)
			{	
				if (spin_cycle == 1) motor1_on();
				if (spin_cycle == 2) motor2_on();
     7e0:	a2 e0       	ldi	r26, 0x02	; 2
     7e2:	aa 16       	cp	r10, r26
     7e4:	b1 04       	cpc	r11, r1
     7e6:	11 f4       	brne	.+4      	; 0x7ec <do_spin_180+0x24e>
	set_motor2_off();
}

void motor2_on(void)
{
	set_motor1_off();
     7e8:	5a 98       	cbi	0x0b, 2	; 11
	set_motor2_on();
     7ea:	5c 9a       	sbi	0x0b, 4	; 11
			{	
				if (spin_cycle == 1) motor1_on();
				if (spin_cycle == 2) motor2_on();
			}

			if ( backward == 1)
     7ec:	e9 89       	ldd	r30, Y+17	; 0x11
     7ee:	fa 89       	ldd	r31, Y+18	; 0x12
     7f0:	31 97       	sbiw	r30, 0x01	; 1
     7f2:	69 f4       	brne	.+26     	; 0x80e <do_spin_180+0x270>
			{	
				if (spin_cycle == 1) motor2_on();
     7f4:	f1 e0       	ldi	r31, 0x01	; 1
     7f6:	af 16       	cp	r10, r31
     7f8:	b1 04       	cpc	r11, r1
     7fa:	19 f4       	brne	.+6      	; 0x802 <do_spin_180+0x264>
	set_motor2_off();
}

void motor2_on(void)
{
	set_motor1_off();
     7fc:	5a 98       	cbi	0x0b, 2	; 11
	set_motor2_on();
     7fe:	5c 9a       	sbi	0x0b, 4	; 11
     800:	06 c0       	rjmp	.+12     	; 0x80e <do_spin_180+0x270>
			}

			if ( backward == 1)
			{	
				if (spin_cycle == 1) motor2_on();
				if (spin_cycle == 2) motor1_on();
     802:	22 e0       	ldi	r18, 0x02	; 2
     804:	a2 16       	cp	r10, r18
     806:	b1 04       	cpc	r11, r1
     808:	11 f4       	brne	.+4      	; 0x80e <do_spin_180+0x270>
}


void motor1_on(void)
{
	set_motor1_on();
     80a:	5a 9a       	sbi	0x0b, 2	; 11
	set_motor2_off();
     80c:	5c 98       	cbi	0x0b, 4	; 11
				if (spin_cycle == 2) motor1_on();
			}
				
		}

		if ( TCNT1 > end_brake ) motors_left();                 //if we hit end of brake cycle - go to full power
     80e:	60 91 84 00 	lds	r22, 0x0084
     812:	70 91 85 00 	lds	r23, 0x0085
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	0e 94 9c 10 	call	0x2138	; 0x2138 <__floatunsisf>
     81e:	29 8d       	ldd	r18, Y+25	; 0x19
     820:	3a 8d       	ldd	r19, Y+26	; 0x1a
     822:	4b 8d       	ldd	r20, Y+27	; 0x1b
     824:	5c 8d       	ldd	r21, Y+28	; 0x1c
     826:	0e 94 4e 11 	call	0x229c	; 0x229c <__gesf2>
     82a:	18 16       	cp	r1, r24
     82c:	14 f4       	brge	.+4      	; 0x832 <do_spin_180+0x294>
}


void motors_left(void)
{
	set_motor1_on();
     82e:	5a 9a       	sbi	0x0b, 2	; 11
	set_motor2_on();
     830:	5c 9a       	sbi	0x0b, 4	; 11
				
		}

		if ( TCNT1 > end_brake ) motors_left();                 //if we hit end of brake cycle - go to full power

		if ( TCNT1 < power_kill_part1 ) motors_off();            //if throttle is less that 100% - kill power at appropriate time
     832:	60 91 84 00 	lds	r22, 0x0084
     836:	70 91 85 00 	lds	r23, 0x0085
     83a:	80 e0       	ldi	r24, 0x00	; 0
     83c:	90 e0       	ldi	r25, 0x00	; 0
     83e:	0e 94 9c 10 	call	0x2138	; 0x2138 <__floatunsisf>
     842:	2b 85       	ldd	r18, Y+11	; 0x0b
     844:	3c 85       	ldd	r19, Y+12	; 0x0c
     846:	4d 85       	ldd	r20, Y+13	; 0x0d
     848:	5e 85       	ldd	r21, Y+14	; 0x0e
     84a:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <__cmpsf2>
     84e:	88 23       	and	r24, r24
     850:	14 f4       	brge	.+4      	; 0x856 <do_spin_180+0x2b8>
}


void motors_off(void)
{
	set_motor1_off();
     852:	5a 98       	cbi	0x0b, 2	; 11
	set_motor2_off();
     854:	5c 98       	cbi	0x0b, 4	; 11
		}

		if ( TCNT1 > end_brake ) motors_left();                 //if we hit end of brake cycle - go to full power

		if ( TCNT1 < power_kill_part1 ) motors_off();            //if throttle is less that 100% - kill power at appropriate time
		if ( TCNT1 > power_kill_part2 ) motors_off();            //if throttle is less that 100% - kill power at appropriate time
     856:	60 91 84 00 	lds	r22, 0x0084
     85a:	70 91 85 00 	lds	r23, 0x0085
     85e:	80 e0       	ldi	r24, 0x00	; 0
     860:	90 e0       	ldi	r25, 0x00	; 0
     862:	0e 94 9c 10 	call	0x2138	; 0x2138 <__floatunsisf>
     866:	2f 81       	ldd	r18, Y+7	; 0x07
     868:	38 85       	ldd	r19, Y+8	; 0x08
     86a:	49 85       	ldd	r20, Y+9	; 0x09
     86c:	5a 85       	ldd	r21, Y+10	; 0x0a
     86e:	0e 94 4e 11 	call	0x229c	; 0x229c <__gesf2>
     872:	18 16       	cp	r1, r24
     874:	14 f4       	brge	.+4      	; 0x87a <do_spin_180+0x2dc>
}


void motors_off(void)
{
	set_motor1_off();
     876:	5a 98       	cbi	0x0b, 2	; 11
	set_motor2_off();
     878:	5c 98       	cbi	0x0b, 4	; 11
		if ( TCNT1 > power_kill_part2 ) motors_off();            //if throttle is less that 100% - kill power at appropriate time

		
		//following code handles turning on and off LED (little confusing)
		
		if (led_on > led_off)
     87a:	c2 01       	movw	r24, r4
     87c:	b1 01       	movw	r22, r2
     87e:	a4 01       	movw	r20, r8
     880:	93 01       	movw	r18, r6
     882:	0e 94 4e 11 	call	0x229c	; 0x229c <__gesf2>
     886:	18 16       	cp	r1, r24
     888:	dc f4       	brge	.+54     	; 0x8c0 <do_spin_180+0x322>
     88a:	10 e0       	ldi	r17, 0x00	; 0
     88c:	c7 01       	movw	r24, r14
     88e:	b6 01       	movw	r22, r12
     890:	a4 01       	movw	r20, r8
     892:	93 01       	movw	r18, r6
     894:	0e 94 4e 11 	call	0x229c	; 0x229c <__gesf2>
     898:	18 16       	cp	r1, r24
     89a:	0c f4       	brge	.+2      	; 0x89e <do_spin_180+0x300>
     89c:	11 e0       	ldi	r17, 0x01	; 1
     89e:	10 27       	eor	r17, r16
     8a0:	41 2f       	mov	r20, r17
     8a2:	50 e0       	ldi	r21, 0x00	; 0
     8a4:	5a a3       	std	Y+34, r21	; 0x22
     8a6:	49 a3       	std	Y+33, r20	; 0x21
		{
			led_is_on_now = 1;
			if ( led_ref > led_off ) led_is_on_now = 0;
			if ( led_ref > led_on ) led_is_on_now = 1;
     8a8:	c7 01       	movw	r24, r14
     8aa:	b6 01       	movw	r22, r12
     8ac:	a2 01       	movw	r20, r4
     8ae:	91 01       	movw	r18, r2
     8b0:	0e 94 4e 11 	call	0x229c	; 0x229c <__gesf2>
     8b4:	18 16       	cp	r1, r24
     8b6:	24 f4       	brge	.+8      	; 0x8c0 <do_spin_180+0x322>
     8b8:	81 e0       	ldi	r24, 0x01	; 1
     8ba:	90 e0       	ldi	r25, 0x00	; 0
     8bc:	9a a3       	std	Y+34, r25	; 0x22
     8be:	89 a3       	std	Y+33, r24	; 0x21
		}


		if (led_off > led_on)
     8c0:	c4 01       	movw	r24, r8
     8c2:	b3 01       	movw	r22, r6
     8c4:	a2 01       	movw	r20, r4
     8c6:	91 01       	movw	r18, r2
     8c8:	0e 94 4e 11 	call	0x229c	; 0x229c <__gesf2>
     8cc:	18 16       	cp	r1, r24
     8ce:	c4 f4       	brge	.+48     	; 0x900 <do_spin_180+0x362>
     8d0:	1a a2       	std	Y+34, r1	; 0x22
     8d2:	19 a2       	std	Y+33, r1	; 0x21
     8d4:	c7 01       	movw	r24, r14
     8d6:	b6 01       	movw	r22, r12
     8d8:	a2 01       	movw	r20, r4
     8da:	91 01       	movw	r18, r2
     8dc:	0e 94 4e 11 	call	0x229c	; 0x229c <__gesf2>
     8e0:	18 16       	cp	r1, r24
     8e2:	24 f4       	brge	.+8      	; 0x8ec <do_spin_180+0x34e>
     8e4:	a1 e0       	ldi	r26, 0x01	; 1
     8e6:	b0 e0       	ldi	r27, 0x00	; 0
     8e8:	ba a3       	std	Y+34, r27	; 0x22
     8ea:	a9 a3       	std	Y+33, r26	; 0x21
		{
		
			led_is_on_now = 0;
			if ( led_ref > led_on ) led_is_on_now = 1;
			if ( led_ref > led_off ) led_is_on_now = 0;
     8ec:	c7 01       	movw	r24, r14
     8ee:	b6 01       	movw	r22, r12
     8f0:	a4 01       	movw	r20, r8
     8f2:	93 01       	movw	r18, r6
     8f4:	0e 94 4e 11 	call	0x229c	; 0x229c <__gesf2>
     8f8:	18 16       	cp	r1, r24
     8fa:	14 f4       	brge	.+4      	; 0x900 <do_spin_180+0x362>
     8fc:	1a a2       	std	Y+34, r1	; 0x22
     8fe:	19 a2       	std	Y+33, r1	; 0x21
		
		}
	
	
		if ( led_is_on_now == 1 )
     900:	29 a1       	ldd	r18, Y+33	; 0x21
     902:	3a a1       	ldd	r19, Y+34	; 0x22
     904:	21 30       	cpi	r18, 0x01	; 1
     906:	31 05       	cpc	r19, r1
     908:	89 f4       	brne	.+34     	; 0x92c <do_spin_180+0x38e>
		{
			//flash the LED if we're in flashy mode - otherwise it's just on
			if ( flashy_led == 1 )
     90a:	4d 81       	ldd	r20, Y+5	; 0x05
     90c:	5e 81       	ldd	r21, Y+6	; 0x06
     90e:	41 30       	cpi	r20, 0x01	; 1
     910:	51 05       	cpc	r21, r1
     912:	51 f4       	brne	.+20     	; 0x928 <do_spin_180+0x38a>
			{
				
				if ((TCNT1 / 160) % 2 == 0) set_led_on(); else set_led_off();
     914:	80 91 84 00 	lds	r24, 0x0084
     918:	90 91 85 00 	lds	r25, 0x0085
     91c:	60 ea       	ldi	r22, 0xA0	; 160
     91e:	70 e0       	ldi	r23, 0x00	; 0
     920:	0e 94 2b 12 	call	0x2456	; 0x2456 <__udivmodhi4>
     924:	60 fd       	sbrc	r22, 0
     926:	06 c0       	rjmp	.+12     	; 0x934 <do_spin_180+0x396>
			}
			else
			{
				set_led_on();
     928:	5d 9a       	sbi	0x0b, 5	; 11
     92a:	05 c0       	rjmp	.+10     	; 0x936 <do_spin_180+0x398>
			}
		}

		if ( led_is_on_now == 0 )
     92c:	89 a1       	ldd	r24, Y+33	; 0x21
     92e:	9a a1       	ldd	r25, Y+34	; 0x22
     930:	89 2b       	or	r24, r25
     932:	09 f4       	brne	.+2      	; 0x936 <do_spin_180+0x398>
		{
			set_led_off();
     934:	5d 98       	cbi	0x0b, 5	; 11

	
void do_spin_180(int spin_cycle)
{	

	while (TCNT1 < half_spin_time)
     936:	60 91 84 00 	lds	r22, 0x0084
     93a:	70 91 85 00 	lds	r23, 0x0085
     93e:	80 e0       	ldi	r24, 0x00	; 0
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	0e 94 9c 10 	call	0x2138	; 0x2138 <__floatunsisf>
     946:	29 81       	ldd	r18, Y+1	; 0x01
     948:	3a 81       	ldd	r19, Y+2	; 0x02
     94a:	4b 81       	ldd	r20, Y+3	; 0x03
     94c:	5c 81       	ldd	r21, Y+4	; 0x04
     94e:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <__cmpsf2>
     952:	87 fd       	sbrc	r24, 7
     954:	bf ce       	rjmp	.-642    	; 0x6d4 <do_spin_180+0x136>
     956:	c0 92 72 01 	sts	0x0172, r12
     95a:	d0 92 73 01 	sts	0x0173, r13
     95e:	e0 92 74 01 	sts	0x0174, r14
     962:	f0 92 75 01 	sts	0x0175, r15
     966:	a9 a1       	ldd	r26, Y+33	; 0x21
     968:	ba a1       	ldd	r27, Y+34	; 0x22
     96a:	b0 93 71 01 	sts	0x0171, r27
     96e:	a0 93 70 01 	sts	0x0170, r26
			set_led_off();
		}
		
	}

}
     972:	a2 96       	adiw	r28, 0x22	; 34
     974:	0f b6       	in	r0, 0x3f	; 63
     976:	f8 94       	cli
     978:	de bf       	out	0x3e, r29	; 62
     97a:	0f be       	out	0x3f, r0	; 63
     97c:	cd bf       	out	0x3d, r28	; 61
     97e:	cf 91       	pop	r28
     980:	df 91       	pop	r29
     982:	1f 91       	pop	r17
     984:	0f 91       	pop	r16
     986:	ff 90       	pop	r15
     988:	ef 90       	pop	r14
     98a:	df 90       	pop	r13
     98c:	cf 90       	pop	r12
     98e:	bf 90       	pop	r11
     990:	af 90       	pop	r10
     992:	9f 90       	pop	r9
     994:	8f 90       	pop	r8
     996:	7f 90       	pop	r7
     998:	6f 90       	pop	r6
     99a:	5f 90       	pop	r5
     99c:	4f 90       	pop	r4
     99e:	3f 90       	pop	r3
     9a0:	2f 90       	pop	r2
     9a2:	08 95       	ret

000009a4 <motors_off>:


void motors_off(void)
{
	set_motor1_off();
     9a4:	5a 98       	cbi	0x0b, 2	; 11
	set_motor2_off();
     9a6:	5c 98       	cbi	0x0b, 4	; 11
}
     9a8:	08 95       	ret

000009aa <motors_left>:


void motors_left(void)
{
	set_motor1_on();
     9aa:	5a 9a       	sbi	0x0b, 2	; 11
	set_motor2_on();
     9ac:	5c 9a       	sbi	0x0b, 4	; 11
}
     9ae:	08 95       	ret

000009b0 <motor1_on>:


void motor1_on(void)
{
	set_motor1_on();
     9b0:	5a 9a       	sbi	0x0b, 2	; 11
	set_motor2_off();
     9b2:	5c 98       	cbi	0x0b, 4	; 11
}
     9b4:	08 95       	ret

000009b6 <motor2_on>:

void motor2_on(void)
{
	set_motor1_off();
     9b6:	5a 98       	cbi	0x0b, 2	; 11
	set_motor2_on();
     9b8:	5c 9a       	sbi	0x0b, 4	; 11
}
     9ba:	08 95       	ret

000009bc <reset_rc>:


void reset_rc(void)
{
	//this routine voids existing RC data - used if timer is going to get reset
	throttle_hightime = 0;
     9bc:	10 92 4a 01 	sts	0x014A, r1
     9c0:	10 92 4b 01 	sts	0x014B, r1
     9c4:	10 92 4c 01 	sts	0x014C, r1
     9c8:	10 92 4d 01 	sts	0x014D, r1
	leftright_hightime = 0;
     9cc:	10 92 52 01 	sts	0x0152, r1
     9d0:	10 92 53 01 	sts	0x0153, r1
     9d4:	10 92 54 01 	sts	0x0154, r1
     9d8:	10 92 55 01 	sts	0x0155, r1
	forwardback_hightime = 0;
     9dc:	10 92 4e 01 	sts	0x014E, r1
     9e0:	10 92 4f 01 	sts	0x014F, r1
     9e4:	10 92 50 01 	sts	0x0150, r1
     9e8:	10 92 51 01 	sts	0x0151, r1

}
     9ec:	08 95       	ret

000009ee <throttle_change>:

//updates RC channels any time specified pin goes high/low
//following 3 routines are all identical except for channels and some safety code in throttle_change (not easy to consolidate them)
void throttle_change(void)
{
     9ee:	ef 92       	push	r14
     9f0:	ff 92       	push	r15
     9f2:	0f 93       	push	r16
     9f4:	1f 93       	push	r17
	
	//did the pin go HIGH? - then note time
	if ( throttle_pin != 0 ) throttle_hightime = TCNT1;    
     9f6:	18 9b       	sbis	0x03, 0	; 3
     9f8:	0e c0       	rjmp	.+28     	; 0xa16 <throttle_change+0x28>
     9fa:	80 91 84 00 	lds	r24, 0x0084
     9fe:	90 91 85 00 	lds	r25, 0x0085
     a02:	a0 e0       	ldi	r26, 0x00	; 0
     a04:	b0 e0       	ldi	r27, 0x00	; 0
     a06:	80 93 4a 01 	sts	0x014A, r24
     a0a:	90 93 4b 01 	sts	0x014B, r25
     a0e:	a0 93 4c 01 	sts	0x014C, r26
     a12:	b0 93 4d 01 	sts	0x014D, r27

	//did the pin go low? - then set timer value as value for this channel / if timer has overflowed then ignore
	if ( throttle_pin == 0 && throttle_hightime != 0 && TCNT1 > throttle_hightime)
     a16:	18 99       	sbic	0x03, 0	; 3
     a18:	59 c0       	rjmp	.+178    	; 0xacc <throttle_change+0xde>
     a1a:	e0 90 4a 01 	lds	r14, 0x014A
     a1e:	f0 90 4b 01 	lds	r15, 0x014B
     a22:	00 91 4c 01 	lds	r16, 0x014C
     a26:	10 91 4d 01 	lds	r17, 0x014D
     a2a:	e1 14       	cp	r14, r1
     a2c:	f1 04       	cpc	r15, r1
     a2e:	01 05       	cpc	r16, r1
     a30:	11 05       	cpc	r17, r1
     a32:	09 f4       	brne	.+2      	; 0xa36 <throttle_change+0x48>
     a34:	4b c0       	rjmp	.+150    	; 0xacc <throttle_change+0xde>
     a36:	80 91 84 00 	lds	r24, 0x0084
     a3a:	90 91 85 00 	lds	r25, 0x0085
     a3e:	a0 e0       	ldi	r26, 0x00	; 0
     a40:	b0 e0       	ldi	r27, 0x00	; 0
     a42:	e8 16       	cp	r14, r24
     a44:	f9 06       	cpc	r15, r25
     a46:	0a 07       	cpc	r16, r26
     a48:	1b 07       	cpc	r17, r27
     a4a:	0c f0       	brlt	.+2      	; 0xa4e <throttle_change+0x60>
     a4c:	3f c0       	rjmp	.+126    	; 0xacc <throttle_change+0xde>
	{		
		throttle = ((throttle * 85) + ((TCNT1 - throttle_hightime) * 15)) / 100;		//smoothed RC data
     a4e:	60 91 86 01 	lds	r22, 0x0186
     a52:	70 91 87 01 	lds	r23, 0x0187
     a56:	80 91 88 01 	lds	r24, 0x0188
     a5a:	90 91 89 01 	lds	r25, 0x0189
     a5e:	20 91 84 00 	lds	r18, 0x0084
     a62:	30 91 85 00 	lds	r19, 0x0085
     a66:	40 e0       	ldi	r20, 0x00	; 0
     a68:	50 e0       	ldi	r21, 0x00	; 0
     a6a:	2e 19       	sub	r18, r14
     a6c:	3f 09       	sbc	r19, r15
     a6e:	40 0b       	sbc	r20, r16
     a70:	51 0b       	sbc	r21, r17
     a72:	79 01       	movw	r14, r18
     a74:	8a 01       	movw	r16, r20
     a76:	e4 e0       	ldi	r30, 0x04	; 4
     a78:	ee 0c       	add	r14, r14
     a7a:	ff 1c       	adc	r15, r15
     a7c:	00 1f       	adc	r16, r16
     a7e:	11 1f       	adc	r17, r17
     a80:	ea 95       	dec	r30
     a82:	d1 f7       	brne	.-12     	; 0xa78 <throttle_change+0x8a>
     a84:	e2 1a       	sub	r14, r18
     a86:	f3 0a       	sbc	r15, r19
     a88:	04 0b       	sbc	r16, r20
     a8a:	15 0b       	sbc	r17, r21
     a8c:	25 e5       	ldi	r18, 0x55	; 85
     a8e:	30 e0       	ldi	r19, 0x00	; 0
     a90:	40 e0       	ldi	r20, 0x00	; 0
     a92:	50 e0       	ldi	r21, 0x00	; 0
     a94:	0e 94 0c 12 	call	0x2418	; 0x2418 <__mulsi3>
     a98:	e6 0e       	add	r14, r22
     a9a:	f7 1e       	adc	r15, r23
     a9c:	08 1f       	adc	r16, r24
     a9e:	19 1f       	adc	r17, r25
     aa0:	c8 01       	movw	r24, r16
     aa2:	b7 01       	movw	r22, r14
     aa4:	24 e6       	ldi	r18, 0x64	; 100
     aa6:	30 e0       	ldi	r19, 0x00	; 0
     aa8:	40 e0       	ldi	r20, 0x00	; 0
     aaa:	50 e0       	ldi	r21, 0x00	; 0
     aac:	0e 94 52 12 	call	0x24a4	; 0x24a4 <__divmodsi4>
     ab0:	c9 01       	movw	r24, r18
     ab2:	da 01       	movw	r26, r20
     ab4:	80 93 86 01 	sts	0x0186, r24
     ab8:	90 93 87 01 	sts	0x0187, r25
     abc:	a0 93 88 01 	sts	0x0188, r26
     ac0:	b0 93 89 01 	sts	0x0189, r27
																						//throttle is highly smoothed to help prevent accidental spin-down
		rotations_since_throttle_was_set = 0;					 //note that throttle was successfully set (for safety)
     ac4:	10 92 43 01 	sts	0x0143, r1
     ac8:	10 92 42 01 	sts	0x0142, r1
	}


	throttle_hilow = throttle_pin;                                  //make note of pin state for reference next time interrupt is triggered...	
     acc:	83 b1       	in	r24, 0x03	; 3
     ace:	90 e0       	ldi	r25, 0x00	; 0
     ad0:	81 70       	andi	r24, 0x01	; 1
     ad2:	90 70       	andi	r25, 0x00	; 0
     ad4:	90 93 bf 01 	sts	0x01BF, r25
     ad8:	80 93 be 01 	sts	0x01BE, r24
	
}
     adc:	1f 91       	pop	r17
     ade:	0f 91       	pop	r16
     ae0:	ff 90       	pop	r15
     ae2:	ef 90       	pop	r14
     ae4:	08 95       	ret

00000ae6 <leftright_change>:

void leftright_change(void)
{
     ae6:	ef 92       	push	r14
     ae8:	ff 92       	push	r15
     aea:	0f 93       	push	r16
     aec:	1f 93       	push	r17
	//did the pin go HIGH? - then note time
	if (leftright_pin != 0 ) leftright_hightime = TCNT1;    
     aee:	19 9b       	sbis	0x03, 1	; 3
     af0:	0e c0       	rjmp	.+28     	; 0xb0e <leftright_change+0x28>
     af2:	80 91 84 00 	lds	r24, 0x0084
     af6:	90 91 85 00 	lds	r25, 0x0085
     afa:	a0 e0       	ldi	r26, 0x00	; 0
     afc:	b0 e0       	ldi	r27, 0x00	; 0
     afe:	80 93 52 01 	sts	0x0152, r24
     b02:	90 93 53 01 	sts	0x0153, r25
     b06:	a0 93 54 01 	sts	0x0154, r26
     b0a:	b0 93 55 01 	sts	0x0155, r27

	//did the pin go low? - then set timer value as value for this channel / if timer has overflowed then ignore
	if (leftright_pin == 0 && leftright_hightime != 0 && TCNT1 > leftright_hightime)
     b0e:	19 99       	sbic	0x03, 1	; 3
     b10:	3e c0       	rjmp	.+124    	; 0xb8e <leftright_change+0xa8>
     b12:	e0 90 52 01 	lds	r14, 0x0152
     b16:	f0 90 53 01 	lds	r15, 0x0153
     b1a:	00 91 54 01 	lds	r16, 0x0154
     b1e:	10 91 55 01 	lds	r17, 0x0155
     b22:	e1 14       	cp	r14, r1
     b24:	f1 04       	cpc	r15, r1
     b26:	01 05       	cpc	r16, r1
     b28:	11 05       	cpc	r17, r1
     b2a:	89 f1       	breq	.+98     	; 0xb8e <leftright_change+0xa8>
     b2c:	80 91 84 00 	lds	r24, 0x0084
     b30:	90 91 85 00 	lds	r25, 0x0085
     b34:	a0 e0       	ldi	r26, 0x00	; 0
     b36:	b0 e0       	ldi	r27, 0x00	; 0
     b38:	e8 16       	cp	r14, r24
     b3a:	f9 06       	cpc	r15, r25
     b3c:	0a 07       	cpc	r16, r26
     b3e:	1b 07       	cpc	r17, r27
     b40:	34 f5       	brge	.+76     	; 0xb8e <leftright_change+0xa8>
	{
			leftright = ((leftright * 50) + ((TCNT1 - leftright_hightime) * 50)) / 100;		//smoothed RC data
     b42:	20 91 8e 01 	lds	r18, 0x018E
     b46:	30 91 8f 01 	lds	r19, 0x018F
     b4a:	40 91 90 01 	lds	r20, 0x0190
     b4e:	50 91 91 01 	lds	r21, 0x0191
     b52:	60 91 84 00 	lds	r22, 0x0084
     b56:	70 91 85 00 	lds	r23, 0x0085
     b5a:	80 e0       	ldi	r24, 0x00	; 0
     b5c:	90 e0       	ldi	r25, 0x00	; 0
     b5e:	6e 19       	sub	r22, r14
     b60:	7f 09       	sbc	r23, r15
     b62:	80 0b       	sbc	r24, r16
     b64:	91 0b       	sbc	r25, r17
     b66:	62 0f       	add	r22, r18
     b68:	73 1f       	adc	r23, r19
     b6a:	84 1f       	adc	r24, r20
     b6c:	95 1f       	adc	r25, r21
     b6e:	22 e0       	ldi	r18, 0x02	; 2
     b70:	30 e0       	ldi	r19, 0x00	; 0
     b72:	40 e0       	ldi	r20, 0x00	; 0
     b74:	50 e0       	ldi	r21, 0x00	; 0
     b76:	0e 94 52 12 	call	0x24a4	; 0x24a4 <__divmodsi4>
     b7a:	c9 01       	movw	r24, r18
     b7c:	da 01       	movw	r26, r20
     b7e:	80 93 8e 01 	sts	0x018E, r24
     b82:	90 93 8f 01 	sts	0x018F, r25
     b86:	a0 93 90 01 	sts	0x0190, r26
     b8a:	b0 93 91 01 	sts	0x0191, r27
	}
  
	leftright_hilow = leftright_pin;                                  //make note of pin state for reference next time interrupt is triggered...	
     b8e:	83 b1       	in	r24, 0x03	; 3
     b90:	90 e0       	ldi	r25, 0x00	; 0
     b92:	82 70       	andi	r24, 0x02	; 2
     b94:	90 70       	andi	r25, 0x00	; 0
     b96:	90 93 5b 01 	sts	0x015B, r25
     b9a:	80 93 5a 01 	sts	0x015A, r24
		
}
     b9e:	1f 91       	pop	r17
     ba0:	0f 91       	pop	r16
     ba2:	ff 90       	pop	r15
     ba4:	ef 90       	pop	r14
     ba6:	08 95       	ret

00000ba8 <forwardback_change>:

void forwardback_change(void)
{
	//did the pin go HIGH? - then note time
	if (forwardback_pin != 0 ) forwardback_hightime = TCNT1;    
     ba8:	1a 9b       	sbis	0x03, 2	; 3
     baa:	0e c0       	rjmp	.+28     	; 0xbc8 <forwardback_change+0x20>
     bac:	80 91 84 00 	lds	r24, 0x0084
     bb0:	90 91 85 00 	lds	r25, 0x0085
     bb4:	a0 e0       	ldi	r26, 0x00	; 0
     bb6:	b0 e0       	ldi	r27, 0x00	; 0
     bb8:	80 93 4e 01 	sts	0x014E, r24
     bbc:	90 93 4f 01 	sts	0x014F, r25
     bc0:	a0 93 50 01 	sts	0x0150, r26
     bc4:	b0 93 51 01 	sts	0x0151, r27

	//did the pin go low? - then set timer value as value for this channel / if timer has overflowed then ignore
	if (forwardback_pin == 0 && forwardback_hightime != 0 && TCNT1 > forwardback_hightime) forwardback = TCNT1 - forwardback_hightime;      
     bc8:	1a 99       	sbic	0x03, 2	; 3
     bca:	2a c0       	rjmp	.+84     	; 0xc20 <forwardback_change+0x78>
     bcc:	20 91 4e 01 	lds	r18, 0x014E
     bd0:	30 91 4f 01 	lds	r19, 0x014F
     bd4:	40 91 50 01 	lds	r20, 0x0150
     bd8:	50 91 51 01 	lds	r21, 0x0151
     bdc:	21 15       	cp	r18, r1
     bde:	31 05       	cpc	r19, r1
     be0:	41 05       	cpc	r20, r1
     be2:	51 05       	cpc	r21, r1
     be4:	e9 f0       	breq	.+58     	; 0xc20 <forwardback_change+0x78>
     be6:	80 91 84 00 	lds	r24, 0x0084
     bea:	90 91 85 00 	lds	r25, 0x0085
     bee:	a0 e0       	ldi	r26, 0x00	; 0
     bf0:	b0 e0       	ldi	r27, 0x00	; 0
     bf2:	28 17       	cp	r18, r24
     bf4:	39 07       	cpc	r19, r25
     bf6:	4a 07       	cpc	r20, r26
     bf8:	5b 07       	cpc	r21, r27
     bfa:	94 f4       	brge	.+36     	; 0xc20 <forwardback_change+0x78>
     bfc:	80 91 84 00 	lds	r24, 0x0084
     c00:	90 91 85 00 	lds	r25, 0x0085
     c04:	a0 e0       	ldi	r26, 0x00	; 0
     c06:	b0 e0       	ldi	r27, 0x00	; 0
     c08:	82 1b       	sub	r24, r18
     c0a:	93 0b       	sbc	r25, r19
     c0c:	a4 0b       	sbc	r26, r20
     c0e:	b5 0b       	sbc	r27, r21
     c10:	80 93 6c 01 	sts	0x016C, r24
     c14:	90 93 6d 01 	sts	0x016D, r25
     c18:	a0 93 6e 01 	sts	0x016E, r26
     c1c:	b0 93 6f 01 	sts	0x016F, r27
  
	forwardback_hilow = forwardback_pin;                               //make note of pin state for reference next time interrupt is triggered...
     c20:	83 b1       	in	r24, 0x03	; 3
     c22:	90 e0       	ldi	r25, 0x00	; 0
     c24:	84 70       	andi	r24, 0x04	; 4
     c26:	90 70       	andi	r25, 0x00	; 0
     c28:	90 93 b7 01 	sts	0x01B7, r25
     c2c:	80 93 b6 01 	sts	0x01B6, r24

}
     c30:	08 95       	ret

00000c32 <__vector_3>:


//main interrupt handler - is called any time any ports on PORTB change

ISR (PCINT0_vect)
{
     c32:	1f 92       	push	r1
     c34:	0f 92       	push	r0
     c36:	0f b6       	in	r0, 0x3f	; 63
     c38:	0f 92       	push	r0
     c3a:	11 24       	eor	r1, r1
     c3c:	2f 93       	push	r18
     c3e:	3f 93       	push	r19
     c40:	4f 93       	push	r20
     c42:	5f 93       	push	r21
     c44:	6f 93       	push	r22
     c46:	7f 93       	push	r23
     c48:	8f 93       	push	r24
     c4a:	9f 93       	push	r25
     c4c:	af 93       	push	r26
     c4e:	bf 93       	push	r27
     c50:	ef 93       	push	r30
     c52:	ff 93       	push	r31
	
	//check all RC channels to see if they were updated
	if (throttle_hilow != throttle_pin) throttle_change();
     c54:	83 b1       	in	r24, 0x03	; 3
     c56:	90 e0       	ldi	r25, 0x00	; 0
     c58:	81 70       	andi	r24, 0x01	; 1
     c5a:	90 70       	andi	r25, 0x00	; 0
     c5c:	20 91 be 01 	lds	r18, 0x01BE
     c60:	30 91 bf 01 	lds	r19, 0x01BF
     c64:	28 17       	cp	r18, r24
     c66:	39 07       	cpc	r19, r25
     c68:	11 f0       	breq	.+4      	; 0xc6e <__vector_3+0x3c>
     c6a:	0e 94 f7 04 	call	0x9ee	; 0x9ee <throttle_change>
	if (leftright_hilow != leftright_pin) leftright_change();
     c6e:	83 b1       	in	r24, 0x03	; 3
     c70:	90 e0       	ldi	r25, 0x00	; 0
     c72:	82 70       	andi	r24, 0x02	; 2
     c74:	90 70       	andi	r25, 0x00	; 0
     c76:	20 91 5a 01 	lds	r18, 0x015A
     c7a:	30 91 5b 01 	lds	r19, 0x015B
     c7e:	28 17       	cp	r18, r24
     c80:	39 07       	cpc	r19, r25
     c82:	11 f0       	breq	.+4      	; 0xc88 <__vector_3+0x56>
     c84:	0e 94 73 05 	call	0xae6	; 0xae6 <leftright_change>
	if (forwardback_hilow != forwardback_pin) forwardback_change();
     c88:	83 b1       	in	r24, 0x03	; 3
     c8a:	90 e0       	ldi	r25, 0x00	; 0
     c8c:	84 70       	andi	r24, 0x04	; 4
     c8e:	90 70       	andi	r25, 0x00	; 0
     c90:	20 91 b6 01 	lds	r18, 0x01B6
     c94:	30 91 b7 01 	lds	r19, 0x01B7
     c98:	28 17       	cp	r18, r24
     c9a:	39 07       	cpc	r19, r25
     c9c:	11 f0       	breq	.+4      	; 0xca2 <__vector_3+0x70>
     c9e:	0e 94 d4 05 	call	0xba8	; 0xba8 <forwardback_change>

}
     ca2:	ff 91       	pop	r31
     ca4:	ef 91       	pop	r30
     ca6:	bf 91       	pop	r27
     ca8:	af 91       	pop	r26
     caa:	9f 91       	pop	r25
     cac:	8f 91       	pop	r24
     cae:	7f 91       	pop	r23
     cb0:	6f 91       	pop	r22
     cb2:	5f 91       	pop	r21
     cb4:	4f 91       	pop	r20
     cb6:	3f 91       	pop	r19
     cb8:	2f 91       	pop	r18
     cba:	0f 90       	pop	r0
     cbc:	0f be       	out	0x3f, r0	; 63
     cbe:	0f 90       	pop	r0
     cc0:	1f 90       	pop	r1
     cc2:	18 95       	reti

00000cc4 <SetupTimer1>:


void SetupTimer1(void)
{

	TCCR1A = 0;                               //mode = 0
     cc4:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0<<CS12 | 1<<CS11 | 1<<CS10;    //prescaler = 64
     cc8:	83 e0       	ldi	r24, 0x03	; 3
     cca:	80 93 81 00 	sts	0x0081, r24

}
     cce:	08 95       	ret

00000cd0 <adc_init>:
void adc_init(void)

{
 
  	// Free running Mode
	ADCSRB = 0x00;
     cd0:	10 92 7b 00 	sts	0x007B, r1

   // Set ADCSRA Register in ATMega168
   ADCSRA = (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1);
     cd4:	86 e8       	ldi	r24, 0x86	; 134
     cd6:	80 93 7a 00 	sts	0x007A, r24

   // Set ADMUX Register in ATMega168
   ADMUX=ADC_PORT_FOR_ACCEL;	
     cda:	84 e0       	ldi	r24, 0x04	; 4
     cdc:	80 93 7c 00 	sts	0x007C, r24

   
}
     ce0:	08 95       	ret

00000ce2 <read_adc>:
{

    unsigned int adc_data;
	
	// Start conversion by setting ADSC on ADCSRA Register
	  ADCSRA |= (1<<ADSC);
     ce2:	80 91 7a 00 	lds	r24, 0x007A
     ce6:	80 64       	ori	r24, 0x40	; 64
     ce8:	80 93 7a 00 	sts	0x007A, r24

	// wait until convertion complete ADSC=0 -> Complete
    while (ADCSRA & (1<<ADSC));
     cec:	80 91 7a 00 	lds	r24, 0x007A
     cf0:	86 fd       	sbrc	r24, 6
     cf2:	fc cf       	rjmp	.-8      	; 0xcec <read_adc+0xa>
	    
	adc_data = ADCL;   
     cf4:	90 91 78 00 	lds	r25, 0x0078

	//shift from low level to high level ADC, from 8bit to 10bit

	adc_data += (ADCH<<8);	  
     cf8:	80 91 79 00 	lds	r24, 0x0079
     cfc:	38 2f       	mov	r19, r24
     cfe:	20 e0       	ldi	r18, 0x00	; 0
     d00:	29 0f       	add	r18, r25
     d02:	31 1d       	adc	r19, r1

	return (adc_data);

}
     d04:	c9 01       	movw	r24, r18
     d06:	08 95       	ret

00000d08 <main_calculations>:



void main_calculations(void)

{
     d08:	2f 92       	push	r2
     d0a:	3f 92       	push	r3
     d0c:	4f 92       	push	r4
     d0e:	5f 92       	push	r5
     d10:	6f 92       	push	r6
     d12:	7f 92       	push	r7
     d14:	8f 92       	push	r8
     d16:	9f 92       	push	r9
     d18:	af 92       	push	r10
     d1a:	bf 92       	push	r11
     d1c:	cf 92       	push	r12
     d1e:	df 92       	push	r13
     d20:	ef 92       	push	r14
     d22:	ff 92       	push	r15
     d24:	0f 93       	push	r16
     d26:	1f 93       	push	r17
     d28:	df 93       	push	r29
     d2a:	cf 93       	push	r28
     d2c:	00 d0       	rcall	.+0      	; 0xd2e <main_calculations+0x26>
     d2e:	00 d0       	rcall	.+0      	; 0xd30 <main_calculations+0x28>
     d30:	00 d0       	rcall	.+0      	; 0xd32 <main_calculations+0x2a>
     d32:	cd b7       	in	r28, 0x3d	; 61
     d34:	de b7       	in	r29, 0x3e	; 62


void reset_rc(void)
{
	//this routine voids existing RC data - used if timer is going to get reset
	throttle_hightime = 0;
     d36:	10 92 4a 01 	sts	0x014A, r1
     d3a:	10 92 4b 01 	sts	0x014B, r1
     d3e:	10 92 4c 01 	sts	0x014C, r1
     d42:	10 92 4d 01 	sts	0x014D, r1
	leftright_hightime = 0;
     d46:	10 92 52 01 	sts	0x0152, r1
     d4a:	10 92 53 01 	sts	0x0153, r1
     d4e:	10 92 54 01 	sts	0x0154, r1
     d52:	10 92 55 01 	sts	0x0155, r1
	forwardback_hightime = 0;
     d56:	10 92 4e 01 	sts	0x014E, r1
     d5a:	10 92 4f 01 	sts	0x014F, r1
     d5e:	10 92 50 01 	sts	0x0150, r1
     d62:	10 92 51 01 	sts	0x0151, r1

{

	reset_rc();				//resets existing RC data - must get called before timer1 is reset to prevent errors
	
	TCNT1 = 0;				//resets timer (used to track for time spent outside motor drive loop)
     d66:	10 92 85 00 	sts	0x0085, r1
     d6a:	10 92 84 00 	sts	0x0084, r1
							//by resetting timer at beginning over each call to main_calculations - the calc time effectively gets included in the do_spin loop


	cli();                	//disable interrupts - bad things seem to happen if the RC interrupts get triggered while doing math...
     d6e:	f8 94       	cli
							//RC data is not updated while in this code

	//Are we going forward or backwards?
	if ( forwardback > (forwardback_center + forwardback_forwardthresh)) forward = 1; else forward = 0;
     d70:	20 91 6c 01 	lds	r18, 0x016C
     d74:	30 91 6d 01 	lds	r19, 0x016D
     d78:	40 91 6e 01 	lds	r20, 0x016E
     d7c:	50 91 6f 01 	lds	r21, 0x016F
     d80:	60 91 04 01 	lds	r22, 0x0104
     d84:	70 91 05 01 	lds	r23, 0x0105
     d88:	80 91 06 01 	lds	r24, 0x0106
     d8c:	90 91 07 01 	lds	r25, 0x0107
     d90:	86 0f       	add	r24, r22
     d92:	97 1f       	adc	r25, r23
     d94:	aa 27       	eor	r26, r26
     d96:	97 fd       	sbrc	r25, 7
     d98:	a0 95       	com	r26
     d9a:	ba 2f       	mov	r27, r26
     d9c:	82 17       	cp	r24, r18
     d9e:	93 07       	cpc	r25, r19
     da0:	a4 07       	cpc	r26, r20
     da2:	b5 07       	cpc	r27, r21
     da4:	3c f4       	brge	.+14     	; 0xdb4 <main_calculations+0xac>
     da6:	81 e0       	ldi	r24, 0x01	; 1
     da8:	90 e0       	ldi	r25, 0x00	; 0
     daa:	90 93 a1 01 	sts	0x01A1, r25
     dae:	80 93 a0 01 	sts	0x01A0, r24
     db2:	04 c0       	rjmp	.+8      	; 0xdbc <main_calculations+0xb4>
     db4:	10 92 a1 01 	sts	0x01A1, r1
     db8:	10 92 a0 01 	sts	0x01A0, r1
	if ( forwardback < (forwardback_center + forwardback_backthresh)) backward = 1; else backward = 0;
     dbc:	20 91 6c 01 	lds	r18, 0x016C
     dc0:	30 91 6d 01 	lds	r19, 0x016D
     dc4:	40 91 6e 01 	lds	r20, 0x016E
     dc8:	50 91 6f 01 	lds	r21, 0x016F
     dcc:	80 91 08 01 	lds	r24, 0x0108
     dd0:	90 91 09 01 	lds	r25, 0x0109
     dd4:	68 0f       	add	r22, r24
     dd6:	79 1f       	adc	r23, r25
     dd8:	cb 01       	movw	r24, r22
     dda:	aa 27       	eor	r26, r26
     ddc:	97 fd       	sbrc	r25, 7
     dde:	a0 95       	com	r26
     de0:	ba 2f       	mov	r27, r26
     de2:	28 17       	cp	r18, r24
     de4:	39 07       	cpc	r19, r25
     de6:	4a 07       	cpc	r20, r26
     de8:	5b 07       	cpc	r21, r27
     dea:	3c f4       	brge	.+14     	; 0xdfa <main_calculations+0xf2>
     dec:	81 e0       	ldi	r24, 0x01	; 1
     dee:	90 e0       	ldi	r25, 0x00	; 0
     df0:	90 93 b1 01 	sts	0x01B1, r25
     df4:	80 93 b0 01 	sts	0x01B0, r24
     df8:	04 c0       	rjmp	.+8      	; 0xe02 <main_calculations+0xfa>
     dfa:	10 92 b1 01 	sts	0x01B1, r1
     dfe:	10 92 b0 01 	sts	0x01B0, r1

	flashy_led = 0;											//by default LED isn't flashy
     e02:	10 92 a3 01 	sts	0x01A3, r1
     e06:	10 92 a2 01 	sts	0x01A2, r1
{

    unsigned int adc_data;
	
	// Start conversion by setting ADSC on ADCSRA Register
	  ADCSRA |= (1<<ADSC);
     e0a:	80 91 7a 00 	lds	r24, 0x007A
     e0e:	80 64       	ori	r24, 0x40	; 64
     e10:	80 93 7a 00 	sts	0x007A, r24

	// wait until convertion complete ADSC=0 -> Complete
    while (ADCSRA & (1<<ADSC));
     e14:	80 91 7a 00 	lds	r24, 0x007A
     e18:	86 fd       	sbrc	r24, 6
     e1a:	fc cf       	rjmp	.-8      	; 0xe14 <main_calculations+0x10c>
	    
	adc_data = ADCL;   
     e1c:	30 91 78 00 	lds	r19, 0x0078

	//shift from low level to high level ADC, from 8bit to 10bit

	adc_data += (ADCH<<8);	  
     e20:	20 91 79 00 	lds	r18, 0x0079
     e24:	72 2f       	mov	r23, r18
     e26:	60 e0       	ldi	r22, 0x00	; 0
     e28:	63 0f       	add	r22, r19
     e2a:	71 1d       	adc	r23, r1
	if ( forwardback > (forwardback_center + forwardback_forwardthresh)) forward = 1; else forward = 0;
	if ( forwardback < (forwardback_center + forwardback_backthresh)) backward = 1; else backward = 0;

	flashy_led = 0;											//by default LED isn't flashy

	accel_raw_data = read_adc();               				//get accel data
     e2c:	70 93 9f 01 	sts	0x019F, r23
     e30:	60 93 9e 01 	sts	0x019E, r22
	
	accel_read = accel_raw_data;                              //move it over to single in case we want to do floating point
	accel_read = accel_read - base_accel;                     //compensate for base (2.5v) level
     e34:	80 e0       	ldi	r24, 0x00	; 0
     e36:	90 e0       	ldi	r25, 0x00	; 0
     e38:	0e 94 9c 10 	call	0x2138	; 0x2138 <__floatunsisf>
     e3c:	7b 01       	movw	r14, r22
     e3e:	8c 01       	movw	r16, r24
     e40:	60 91 34 01 	lds	r22, 0x0134
     e44:	70 91 35 01 	lds	r23, 0x0135
     e48:	88 27       	eor	r24, r24
     e4a:	77 fd       	sbrc	r23, 7
     e4c:	80 95       	com	r24
     e4e:	98 2f       	mov	r25, r24
     e50:	0e 94 9e 10 	call	0x213c	; 0x213c <__floatsisf>
     e54:	9b 01       	movw	r18, r22
     e56:	ac 01       	movw	r20, r24
     e58:	c8 01       	movw	r24, r16
     e5a:	b7 01       	movw	r22, r14
     e5c:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <__subsf3>
     e60:	60 93 9a 01 	sts	0x019A, r22
     e64:	70 93 9b 01 	sts	0x019B, r23
     e68:	80 93 9c 01 	sts	0x019C, r24
     e6c:	90 93 9d 01 	sts	0x019D, r25
	g = accel_read * g_per_adc_increment;                    //convert to g's
     e70:	20 91 20 01 	lds	r18, 0x0120
     e74:	30 91 21 01 	lds	r19, 0x0121
     e78:	40 91 22 01 	lds	r20, 0x0122
     e7c:	50 91 23 01 	lds	r21, 0x0123
     e80:	0e 94 52 11 	call	0x22a4	; 0x22a4 <__mulsf3>
     e84:	3b 01       	movw	r6, r22
     e86:	4c 01       	movw	r8, r24
     e88:	60 93 76 01 	sts	0x0176, r22
     e8c:	70 93 77 01 	sts	0x0177, r23
     e90:	80 93 78 01 	sts	0x0178, r24
     e94:	90 93 79 01 	sts	0x0179, r25

	rpm = g * 89445;                                //calculate RPM from g's - derived from "G = 0.00001118 * r * RPM^2"
	rpm = rpm / radius;
	rpm = pow(rpm, .5);								
     e98:	20 e8       	ldi	r18, 0x80	; 128
     e9a:	32 eb       	ldi	r19, 0xB2	; 178
     e9c:	4e ea       	ldi	r20, 0xAE	; 174
     e9e:	57 e4       	ldi	r21, 0x47	; 71
     ea0:	0e 94 52 11 	call	0x22a4	; 0x22a4 <__mulsf3>
     ea4:	20 91 1c 01 	lds	r18, 0x011C
     ea8:	30 91 1d 01 	lds	r19, 0x011D
     eac:	40 91 1e 01 	lds	r20, 0x011E
     eb0:	50 91 1f 01 	lds	r21, 0x011F
     eb4:	0e 94 03 10 	call	0x2006	; 0x2006 <__divsf3>
     eb8:	0e 94 b9 11 	call	0x2372	; 0x2372 <sqrt>
     ebc:	7b 01       	movw	r14, r22
     ebe:	8c 01       	movw	r16, r24
     ec0:	17 01       	movw	r2, r14
     ec2:	28 01       	movw	r4, r16
     ec4:	e0 92 a4 01 	sts	0x01A4, r14
     ec8:	f0 92 a5 01 	sts	0x01A5, r15
     ecc:	00 93 a6 01 	sts	0x01A6, r16
     ed0:	10 93 a7 01 	sts	0x01A7, r17
	
	if (rpm > max_observed_rpm) max_observed_rpm = rpm;		//update max_observed_rpm if current rpm is higher
     ed4:	60 91 46 01 	lds	r22, 0x0146
     ed8:	70 91 47 01 	lds	r23, 0x0147
     edc:	80 91 48 01 	lds	r24, 0x0148
     ee0:	90 91 49 01 	lds	r25, 0x0149
     ee4:	0e 94 9e 10 	call	0x213c	; 0x213c <__floatsisf>
     ee8:	9b 01       	movw	r18, r22
     eea:	ac 01       	movw	r20, r24
     eec:	c8 01       	movw	r24, r16
     eee:	b7 01       	movw	r22, r14
     ef0:	0e 94 4e 11 	call	0x229c	; 0x229c <__gesf2>
     ef4:	18 16       	cp	r1, r24
     ef6:	64 f4       	brge	.+24     	; 0xf10 <main_calculations+0x208>
     ef8:	c8 01       	movw	r24, r16
     efa:	b7 01       	movw	r22, r14
     efc:	0e 94 6b 10 	call	0x20d6	; 0x20d6 <__fixsfsi>
     f00:	60 93 46 01 	sts	0x0146, r22
     f04:	70 93 47 01 	sts	0x0147, r23
     f08:	80 93 48 01 	sts	0x0148, r24
     f0c:	90 93 49 01 	sts	0x0149, r25
	
	full_spin_time_ms = rpm / 60;                                      //convert RPM to duration of each spin in milliseconds
     f10:	c2 01       	movw	r24, r4
     f12:	b1 01       	movw	r22, r2
     f14:	20 e0       	ldi	r18, 0x00	; 0
     f16:	30 e0       	ldi	r19, 0x00	; 0
     f18:	40 e7       	ldi	r20, 0x70	; 112
     f1a:	52 e4       	ldi	r21, 0x42	; 66
     f1c:	0e 94 03 10 	call	0x2006	; 0x2006 <__divsf3>
     f20:	60 93 5c 01 	sts	0x015C, r22
     f24:	70 93 5d 01 	sts	0x015D, r23
     f28:	80 93 5e 01 	sts	0x015E, r24
     f2c:	90 93 5f 01 	sts	0x015F, r25
		
	if (full_spin_time_ms == 0) full_spin_time_ms = 1;                          //must prevent any possible division by zero!!!
     f30:	20 e0       	ldi	r18, 0x00	; 0
     f32:	30 e0       	ldi	r19, 0x00	; 0
     f34:	40 e0       	ldi	r20, 0x00	; 0
     f36:	50 e0       	ldi	r21, 0x00	; 0
     f38:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <__cmpsf2>
     f3c:	88 23       	and	r24, r24
     f3e:	61 f4       	brne	.+24     	; 0xf58 <main_calculations+0x250>
     f40:	80 e0       	ldi	r24, 0x00	; 0
     f42:	90 e0       	ldi	r25, 0x00	; 0
     f44:	a0 e8       	ldi	r26, 0x80	; 128
     f46:	bf e3       	ldi	r27, 0x3F	; 63
     f48:	80 93 5c 01 	sts	0x015C, r24
     f4c:	90 93 5d 01 	sts	0x015D, r25
     f50:	a0 93 5e 01 	sts	0x015E, r26
     f54:	b0 93 5f 01 	sts	0x015F, r27
	full_spin_time_ms = 1 / full_spin_time_ms;
	full_spin_time_ms = full_spin_time_ms * 1000;									//seconds to milliseconds

	full_spin_time_ms = full_spin_time_ms * tracking_comp;                      //compensate with user-set tracking adjustment
     f58:	60 e0       	ldi	r22, 0x00	; 0
     f5a:	70 e0       	ldi	r23, 0x00	; 0
     f5c:	80 e8       	ldi	r24, 0x80	; 128
     f5e:	9f e3       	ldi	r25, 0x3F	; 63
     f60:	20 91 5c 01 	lds	r18, 0x015C
     f64:	30 91 5d 01 	lds	r19, 0x015D
     f68:	40 91 5e 01 	lds	r20, 0x015E
     f6c:	50 91 5f 01 	lds	r21, 0x015F
     f70:	0e 94 03 10 	call	0x2006	; 0x2006 <__divsf3>
     f74:	20 e0       	ldi	r18, 0x00	; 0
     f76:	30 e0       	ldi	r19, 0x00	; 0
     f78:	4a e7       	ldi	r20, 0x7A	; 122
     f7a:	54 e4       	ldi	r21, 0x44	; 68
     f7c:	0e 94 52 11 	call	0x22a4	; 0x22a4 <__mulsf3>
     f80:	20 91 2c 01 	lds	r18, 0x012C
     f84:	30 91 2d 01 	lds	r19, 0x012D
     f88:	40 91 2e 01 	lds	r20, 0x012E
     f8c:	50 91 2f 01 	lds	r21, 0x012F
     f90:	0e 94 52 11 	call	0x22a4	; 0x22a4 <__mulsf3>
     f94:	9b 01       	movw	r18, r22
     f96:	ac 01       	movw	r20, r24
     f98:	60 93 5c 01 	sts	0x015C, r22
     f9c:	70 93 5d 01 	sts	0x015D, r23
     fa0:	80 93 5e 01 	sts	0x015E, r24
     fa4:	90 93 5f 01 	sts	0x015F, r25

  
	if ( forward == 1 ) full_spin_time_ms = full_spin_time_ms * forward_comp;   //extra compensation if going forward
     fa8:	80 91 a0 01 	lds	r24, 0x01A0
     fac:	90 91 a1 01 	lds	r25, 0x01A1
     fb0:	01 97       	sbiw	r24, 0x01	; 1
     fb2:	a1 f4       	brne	.+40     	; 0xfdc <main_calculations+0x2d4>
     fb4:	ca 01       	movw	r24, r20
     fb6:	b9 01       	movw	r22, r18
     fb8:	20 91 24 01 	lds	r18, 0x0124
     fbc:	30 91 25 01 	lds	r19, 0x0125
     fc0:	40 91 26 01 	lds	r20, 0x0126
     fc4:	50 91 27 01 	lds	r21, 0x0127
     fc8:	0e 94 52 11 	call	0x22a4	; 0x22a4 <__mulsf3>
     fcc:	60 93 5c 01 	sts	0x015C, r22
     fd0:	70 93 5d 01 	sts	0x015D, r23
     fd4:	80 93 5e 01 	sts	0x015E, r24
     fd8:	90 93 5f 01 	sts	0x015F, r25
	if ( backward == 1 ) full_spin_time_ms = full_spin_time_ms * backward_comp; //extra compensation if going backward
     fdc:	80 91 b0 01 	lds	r24, 0x01B0
     fe0:	90 91 b1 01 	lds	r25, 0x01B1
     fe4:	01 97       	sbiw	r24, 0x01	; 1
     fe6:	d1 f4       	brne	.+52     	; 0x101c <main_calculations+0x314>
     fe8:	60 91 5c 01 	lds	r22, 0x015C
     fec:	70 91 5d 01 	lds	r23, 0x015D
     ff0:	80 91 5e 01 	lds	r24, 0x015E
     ff4:	90 91 5f 01 	lds	r25, 0x015F
     ff8:	20 91 28 01 	lds	r18, 0x0128
     ffc:	30 91 29 01 	lds	r19, 0x0129
    1000:	40 91 2a 01 	lds	r20, 0x012A
    1004:	50 91 2b 01 	lds	r21, 0x012B
    1008:	0e 94 52 11 	call	0x22a4	; 0x22a4 <__mulsf3>
    100c:	60 93 5c 01 	sts	0x015C, r22
    1010:	70 93 5d 01 	sts	0x015D, r23
    1014:	80 93 5e 01 	sts	0x015E, r24
    1018:	90 93 5f 01 	sts	0x015F, r25



	//converts throttle reading from remote into percentage
	throttle_percent = ((throttle - throttle_low) * 100) / (throttle_high - throttle_low);
    101c:	60 91 86 01 	lds	r22, 0x0186
    1020:	70 91 87 01 	lds	r23, 0x0187
    1024:	80 91 88 01 	lds	r24, 0x0188
    1028:	90 91 89 01 	lds	r25, 0x0189
    102c:	00 91 00 01 	lds	r16, 0x0100
    1030:	10 91 01 01 	lds	r17, 0x0101
    1034:	98 01       	movw	r18, r16
    1036:	44 27       	eor	r20, r20
    1038:	37 fd       	sbrc	r19, 7
    103a:	40 95       	com	r20
    103c:	54 2f       	mov	r21, r20
    103e:	62 1b       	sub	r22, r18
    1040:	73 0b       	sbc	r23, r19
    1042:	84 0b       	sbc	r24, r20
    1044:	95 0b       	sbc	r25, r21
    1046:	24 e6       	ldi	r18, 0x64	; 100
    1048:	30 e0       	ldi	r19, 0x00	; 0
    104a:	40 e0       	ldi	r20, 0x00	; 0
    104c:	50 e0       	ldi	r21, 0x00	; 0
    104e:	0e 94 0c 12 	call	0x2418	; 0x2418 <__mulsi3>
    1052:	20 91 02 01 	lds	r18, 0x0102
    1056:	30 91 03 01 	lds	r19, 0x0103
    105a:	20 1b       	sub	r18, r16
    105c:	31 0b       	sbc	r19, r17
    105e:	44 27       	eor	r20, r20
    1060:	37 fd       	sbrc	r19, 7
    1062:	40 95       	com	r20
    1064:	54 2f       	mov	r21, r20
    1066:	0e 94 52 12 	call	0x24a4	; 0x24a4 <__divmodsi4>
    106a:	ca 01       	movw	r24, r20
    106c:	b9 01       	movw	r22, r18
    106e:	0e 94 9e 10 	call	0x213c	; 0x213c <__floatsisf>
    1072:	60 93 ac 01 	sts	0x01AC, r22
    1076:	70 93 ad 01 	sts	0x01AD, r23
    107a:	80 93 ae 01 	sts	0x01AE, r24
    107e:	90 93 af 01 	sts	0x01AF, r25
	if ( throttle_percent < 12 ) throttle_percent = 12;    //don't got under X%	 (throttle percent is only set if we exit safety - so lack of "0" throttle isn't a problem)
    1082:	20 e0       	ldi	r18, 0x00	; 0
    1084:	30 e0       	ldi	r19, 0x00	; 0
    1086:	40 e4       	ldi	r20, 0x40	; 64
    1088:	51 e4       	ldi	r21, 0x41	; 65
    108a:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <__cmpsf2>
    108e:	88 23       	and	r24, r24
    1090:	64 f4       	brge	.+24     	; 0x10aa <main_calculations+0x3a2>
    1092:	80 e0       	ldi	r24, 0x00	; 0
    1094:	90 e0       	ldi	r25, 0x00	; 0
    1096:	a0 e4       	ldi	r26, 0x40	; 64
    1098:	b1 e4       	ldi	r27, 0x41	; 65
    109a:	80 93 ac 01 	sts	0x01AC, r24
    109e:	90 93 ad 01 	sts	0x01AD, r25
    10a2:	a0 93 ae 01 	sts	0x01AE, r26
    10a6:	b0 93 af 01 	sts	0x01AF, r27
	if ( throttle_percent > 100 ) throttle_percent = 100;    //don't got over 100%
    10aa:	60 91 ac 01 	lds	r22, 0x01AC
    10ae:	70 91 ad 01 	lds	r23, 0x01AD
    10b2:	80 91 ae 01 	lds	r24, 0x01AE
    10b6:	90 91 af 01 	lds	r25, 0x01AF
    10ba:	20 e0       	ldi	r18, 0x00	; 0
    10bc:	30 e0       	ldi	r19, 0x00	; 0
    10be:	48 ec       	ldi	r20, 0xC8	; 200
    10c0:	52 e4       	ldi	r21, 0x42	; 66
    10c2:	0e 94 4e 11 	call	0x229c	; 0x229c <__gesf2>
    10c6:	18 16       	cp	r1, r24
    10c8:	64 f4       	brge	.+24     	; 0x10e2 <main_calculations+0x3da>
    10ca:	80 e0       	ldi	r24, 0x00	; 0
    10cc:	90 e0       	ldi	r25, 0x00	; 0
    10ce:	a8 ec       	ldi	r26, 0xC8	; 200
    10d0:	b2 e4       	ldi	r27, 0x42	; 66
    10d2:	80 93 ac 01 	sts	0x01AC, r24
    10d6:	90 93 ad 01 	sts	0x01AD, r25
    10da:	a0 93 ae 01 	sts	0x01AE, r26
    10de:	b0 93 af 01 	sts	0x01AF, r27
	

	config_mode_throttle_percent = throttle_percent;				//second copy of variable used in config mode (since we're otherwise locking it at 50%)
    10e2:	20 91 ac 01 	lds	r18, 0x01AC
    10e6:	30 91 ad 01 	lds	r19, 0x01AD
    10ea:	40 91 ae 01 	lds	r20, 0x01AE
    10ee:	50 91 af 01 	lds	r21, 0x01AF
    10f2:	20 93 b2 01 	sts	0x01B2, r18
    10f6:	30 93 b3 01 	sts	0x01B3, r19
    10fa:	40 93 b4 01 	sts	0x01B4, r20
    10fe:	50 93 b5 01 	sts	0x01B5, r21
	if (in_config_mode == 1) throttle_percent = 50;			//throttle is locked at 50 percent in config mode
    1102:	80 91 c0 01 	lds	r24, 0x01C0
    1106:	90 91 c1 01 	lds	r25, 0x01C1
    110a:	9e 83       	std	Y+6, r25	; 0x06
    110c:	8d 83       	std	Y+5, r24	; 0x05
    110e:	01 97       	sbiw	r24, 0x01	; 1
    1110:	69 f4       	brne	.+26     	; 0x112c <main_calculations+0x424>
    1112:	80 e0       	ldi	r24, 0x00	; 0
    1114:	90 e0       	ldi	r25, 0x00	; 0
    1116:	a8 e4       	ldi	r26, 0x48	; 72
    1118:	b2 e4       	ldi	r27, 0x42	; 66
    111a:	80 93 ac 01 	sts	0x01AC, r24
    111e:	90 93 ad 01 	sts	0x01AD, r25
    1122:	a0 93 ae 01 	sts	0x01AE, r26
    1126:	b0 93 af 01 	sts	0x01AF, r27
    112a:	04 c0       	rjmp	.+8      	; 0x1134 <main_calculations+0x42c>


	//calculates + modifies changes to heading based on input from transmitter - not done if in config mode (and not in the 90+% normal drive mode)
	
	if (in_config_mode == 0 || config_mode_throttle_percent > 90)
    112c:	ad 81       	ldd	r26, Y+5	; 0x05
    112e:	be 81       	ldd	r27, Y+6	; 0x06
    1130:	ab 2b       	or	r26, r27
    1132:	59 f0       	breq	.+22     	; 0x114a <main_calculations+0x442>
    1134:	ca 01       	movw	r24, r20
    1136:	b9 01       	movw	r22, r18
    1138:	20 e0       	ldi	r18, 0x00	; 0
    113a:	30 e0       	ldi	r19, 0x00	; 0
    113c:	44 eb       	ldi	r20, 0xB4	; 180
    113e:	52 e4       	ldi	r21, 0x42	; 66
    1140:	0e 94 4e 11 	call	0x229c	; 0x229c <__gesf2>
    1144:	18 16       	cp	r1, r24
    1146:	0c f0       	brlt	.+2      	; 0x114a <main_calculations+0x442>
    1148:	44 c0       	rjmp	.+136    	; 0x11d2 <main_calculations+0x4ca>
	{
		steering_multiplier = heading_center - leftright;
    114a:	20 91 8e 01 	lds	r18, 0x018E
    114e:	30 91 8f 01 	lds	r19, 0x018F
    1152:	40 91 90 01 	lds	r20, 0x0190
    1156:	50 91 91 01 	lds	r21, 0x0191
		steering_multiplier = steering_multiplier * turn_speed;
    115a:	60 91 0a 01 	lds	r22, 0x010A
    115e:	70 91 0b 01 	lds	r23, 0x010B
    1162:	88 27       	eor	r24, r24
    1164:	77 fd       	sbrc	r23, 7
    1166:	80 95       	com	r24
    1168:	98 2f       	mov	r25, r24
    116a:	62 1b       	sub	r22, r18
    116c:	73 0b       	sbc	r23, r19
    116e:	84 0b       	sbc	r24, r20
    1170:	95 0b       	sbc	r25, r21
    1172:	0e 94 9e 10 	call	0x213c	; 0x213c <__floatsisf>
    1176:	20 91 36 01 	lds	r18, 0x0136
    117a:	30 91 37 01 	lds	r19, 0x0137
    117e:	40 91 38 01 	lds	r20, 0x0138
    1182:	50 91 39 01 	lds	r21, 0x0139
    1186:	0e 94 52 11 	call	0x22a4	; 0x22a4 <__mulsf3>
    118a:	9b 01       	movw	r18, r22
    118c:	ac 01       	movw	r20, r24
		steering_multiplier = 1 - steering_multiplier;		//starts with 1 as a base value (ie - if it was 0.0 it becomes 1.0 - so there's no change in heading)
    118e:	60 e0       	ldi	r22, 0x00	; 0
    1190:	70 e0       	ldi	r23, 0x00	; 0
    1192:	80 e8       	ldi	r24, 0x80	; 128
    1194:	9f e3       	ldi	r25, 0x3F	; 63
    1196:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <__subsf3>
    119a:	9b 01       	movw	r18, r22
    119c:	ac 01       	movw	r20, r24
    119e:	60 93 56 01 	sts	0x0156, r22
    11a2:	70 93 57 01 	sts	0x0157, r23
    11a6:	80 93 58 01 	sts	0x0158, r24
    11aa:	90 93 59 01 	sts	0x0159, r25
		full_spin_time_ms = full_spin_time_ms * steering_multiplier;
    11ae:	60 91 5c 01 	lds	r22, 0x015C
    11b2:	70 91 5d 01 	lds	r23, 0x015D
    11b6:	80 91 5e 01 	lds	r24, 0x015E
    11ba:	90 91 5f 01 	lds	r25, 0x015F
    11be:	0e 94 52 11 	call	0x22a4	; 0x22a4 <__mulsf3>
    11c2:	60 93 5c 01 	sts	0x015C, r22
    11c6:	70 93 5d 01 	sts	0x015D, r23
    11ca:	80 93 5e 01 	sts	0x015E, r24
    11ce:	90 93 5f 01 	sts	0x015F, r25
	}
	

	half_spin_time = full_spin_time_ms / 2;                          //sets period in MS for each half of spin
    11d2:	a0 90 5c 01 	lds	r10, 0x015C
    11d6:	b0 90 5d 01 	lds	r11, 0x015D
    11da:	c0 90 5e 01 	lds	r12, 0x015E
    11de:	d0 90 5f 01 	lds	r13, 0x015F
    11e2:	c6 01       	movw	r24, r12
    11e4:	b5 01       	movw	r22, r10
    11e6:	20 e0       	ldi	r18, 0x00	; 0
    11e8:	30 e0       	ldi	r19, 0x00	; 0
    11ea:	40 e0       	ldi	r20, 0x00	; 0
    11ec:	5f e3       	ldi	r21, 0x3F	; 63
    11ee:	0e 94 52 11 	call	0x22a4	; 0x22a4 <__mulsf3>
    11f2:	60 93 8a 01 	sts	0x018A, r22
    11f6:	70 93 8b 01 	sts	0x018B, r23
    11fa:	80 93 8c 01 	sts	0x018C, r24
    11fe:	90 93 8d 01 	sts	0x018D, r25

	//caps on timing if going too slow or fast
	if ( half_spin_time > 200) half_spin_time = 200;			//slowest allowed - 200ms per half-cycle = 150rpm
    1202:	20 e0       	ldi	r18, 0x00	; 0
    1204:	30 e0       	ldi	r19, 0x00	; 0
    1206:	48 e4       	ldi	r20, 0x48	; 72
    1208:	53 e4       	ldi	r21, 0x43	; 67
    120a:	0e 94 4e 11 	call	0x229c	; 0x229c <__gesf2>
    120e:	18 16       	cp	r1, r24
    1210:	64 f4       	brge	.+24     	; 0x122a <main_calculations+0x522>
    1212:	80 e0       	ldi	r24, 0x00	; 0
    1214:	90 e0       	ldi	r25, 0x00	; 0
    1216:	a8 e4       	ldi	r26, 0x48	; 72
    1218:	b3 e4       	ldi	r27, 0x43	; 67
    121a:	80 93 8a 01 	sts	0x018A, r24
    121e:	90 93 8b 01 	sts	0x018B, r25
    1222:	a0 93 8c 01 	sts	0x018C, r26
    1226:	b0 93 8d 01 	sts	0x018D, r27
	if ( half_spin_time < 5) half_spin_time = 5;				//fastest - 5ms per half-cycle = 6000rpm
    122a:	60 91 8a 01 	lds	r22, 0x018A
    122e:	70 91 8b 01 	lds	r23, 0x018B
    1232:	80 91 8c 01 	lds	r24, 0x018C
    1236:	90 91 8d 01 	lds	r25, 0x018D
    123a:	20 e0       	ldi	r18, 0x00	; 0
    123c:	30 e0       	ldi	r19, 0x00	; 0
    123e:	40 ea       	ldi	r20, 0xA0	; 160
    1240:	50 e4       	ldi	r21, 0x40	; 64
    1242:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <__cmpsf2>
    1246:	88 23       	and	r24, r24
    1248:	64 f4       	brge	.+24     	; 0x1262 <main_calculations+0x55a>
    124a:	80 e0       	ldi	r24, 0x00	; 0
    124c:	90 e0       	ldi	r25, 0x00	; 0
    124e:	a0 ea       	ldi	r26, 0xA0	; 160
    1250:	b0 e4       	ldi	r27, 0x40	; 64
    1252:	80 93 8a 01 	sts	0x018A, r24
    1256:	90 93 8b 01 	sts	0x018B, r25
    125a:	a0 93 8c 01 	sts	0x018C, r26
    125e:	b0 93 8d 01 	sts	0x018D, r27


	//set heading beacon size and location

	led_on = full_spin_time_ms * led_adjust;
	led_on = led_on / 100;
    1262:	c6 01       	movw	r24, r12
    1264:	b5 01       	movw	r22, r10
    1266:	20 91 30 01 	lds	r18, 0x0130
    126a:	30 91 31 01 	lds	r19, 0x0131
    126e:	40 91 32 01 	lds	r20, 0x0132
    1272:	50 91 33 01 	lds	r21, 0x0133
    1276:	0e 94 52 11 	call	0x22a4	; 0x22a4 <__mulsf3>
    127a:	20 e0       	ldi	r18, 0x00	; 0
    127c:	30 e0       	ldi	r19, 0x00	; 0
    127e:	48 ec       	ldi	r20, 0xC8	; 200
    1280:	52 e4       	ldi	r21, 0x42	; 66
    1282:	0e 94 03 10 	call	0x2006	; 0x2006 <__divsf3>
    1286:	7b 01       	movw	r14, r22
    1288:	8c 01       	movw	r16, r24
    128a:	60 93 96 01 	sts	0x0196, r22
    128e:	70 93 97 01 	sts	0x0197, r23
    1292:	80 93 98 01 	sts	0x0198, r24
    1296:	90 93 99 01 	sts	0x0199, r25
	led_off = full_spin_time_ms / 3;                                  //led signal is 33% of circle
	led_off = led_off + led_on;
    129a:	c6 01       	movw	r24, r12
    129c:	b5 01       	movw	r22, r10
    129e:	20 e0       	ldi	r18, 0x00	; 0
    12a0:	30 e0       	ldi	r19, 0x00	; 0
    12a2:	40 e4       	ldi	r20, 0x40	; 64
    12a4:	50 e4       	ldi	r21, 0x40	; 64
    12a6:	0e 94 03 10 	call	0x2006	; 0x2006 <__divsf3>
    12aa:	a8 01       	movw	r20, r16
    12ac:	97 01       	movw	r18, r14
    12ae:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <__addsf3>
    12b2:	7b 01       	movw	r14, r22
    12b4:	8c 01       	movw	r16, r24
    12b6:	60 93 b8 01 	sts	0x01B8, r22
    12ba:	70 93 b9 01 	sts	0x01B9, r23
    12be:	80 93 ba 01 	sts	0x01BA, r24
    12c2:	90 93 bb 01 	sts	0x01BB, r25


	if (led_off >= full_spin_time_ms ) //if led_off is "later" or at end of cycle - shift led_off behind by one cycle
    12c6:	a6 01       	movw	r20, r12
    12c8:	95 01       	movw	r18, r10
    12ca:	0e 94 4e 11 	call	0x229c	; 0x229c <__gesf2>
    12ce:	88 23       	and	r24, r24
    12d0:	74 f0       	brlt	.+28     	; 0x12ee <main_calculations+0x5e6>
	{                        
		led_off = led_off - full_spin_time_ms;
    12d2:	c8 01       	movw	r24, r16
    12d4:	b7 01       	movw	r22, r14
    12d6:	a6 01       	movw	r20, r12
    12d8:	95 01       	movw	r18, r10
    12da:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <__subsf3>
    12de:	60 93 b8 01 	sts	0x01B8, r22
    12e2:	70 93 b9 01 	sts	0x01B9, r23
    12e6:	80 93 ba 01 	sts	0x01BA, r24
    12ea:	90 93 bb 01 	sts	0x01BB, r25
	}

	if ( led_off < 1 ) led_off = led_off + full_spin_time_ms;
    12ee:	e0 90 b8 01 	lds	r14, 0x01B8
    12f2:	f0 90 b9 01 	lds	r15, 0x01B9
    12f6:	00 91 ba 01 	lds	r16, 0x01BA
    12fa:	10 91 bb 01 	lds	r17, 0x01BB
    12fe:	c8 01       	movw	r24, r16
    1300:	b7 01       	movw	r22, r14
    1302:	20 e0       	ldi	r18, 0x00	; 0
    1304:	30 e0       	ldi	r19, 0x00	; 0
    1306:	40 e8       	ldi	r20, 0x80	; 128
    1308:	5f e3       	ldi	r21, 0x3F	; 63
    130a:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <__cmpsf2>
    130e:	88 23       	and	r24, r24
    1310:	74 f4       	brge	.+28     	; 0x132e <main_calculations+0x626>
    1312:	c8 01       	movw	r24, r16
    1314:	b7 01       	movw	r22, r14
    1316:	a6 01       	movw	r20, r12
    1318:	95 01       	movw	r18, r10
    131a:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <__addsf3>
    131e:	60 93 b8 01 	sts	0x01B8, r22
    1322:	70 93 b9 01 	sts	0x01B9, r23
    1326:	80 93 ba 01 	sts	0x01BA, r24
    132a:	90 93 bb 01 	sts	0x01BB, r25

	//throttling

	full_power_spin = 0;
    132e:	10 92 bd 01 	sts	0x01BD, r1
    1332:	10 92 bc 01 	sts	0x01BC, r1
	if ( rpm < min_rpm ) full_power_spin = 1;                //if we're under the minimum RPM for translation - do the full power spin!
    1336:	c2 01       	movw	r24, r4
    1338:	b1 01       	movw	r22, r2
    133a:	20 91 10 01 	lds	r18, 0x0110
    133e:	30 91 11 01 	lds	r19, 0x0111
    1342:	40 91 12 01 	lds	r20, 0x0112
    1346:	50 91 13 01 	lds	r21, 0x0113
    134a:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <__cmpsf2>
    134e:	88 23       	and	r24, r24
    1350:	34 f4       	brge	.+12     	; 0x135e <main_calculations+0x656>
    1352:	81 e0       	ldi	r24, 0x01	; 1
    1354:	90 e0       	ldi	r25, 0x00	; 0
    1356:	90 93 bd 01 	sts	0x01BD, r25
    135a:	80 93 bc 01 	sts	0x01BC, r24
	if ( g > max_g || rpm > max_allowed_rpm ) throttle_percent = 10;  				     //if we're over max alowed G's or RPM - reduce throttle
    135e:	c4 01       	movw	r24, r8
    1360:	b3 01       	movw	r22, r6
    1362:	20 91 18 01 	lds	r18, 0x0118
    1366:	30 91 19 01 	lds	r19, 0x0119
    136a:	40 91 1a 01 	lds	r20, 0x011A
    136e:	50 91 1b 01 	lds	r21, 0x011B
    1372:	0e 94 4e 11 	call	0x229c	; 0x229c <__gesf2>
    1376:	18 16       	cp	r1, r24
    1378:	74 f0       	brlt	.+28     	; 0x1396 <main_calculations+0x68e>
    137a:	c2 01       	movw	r24, r4
    137c:	b1 01       	movw	r22, r2
    137e:	20 91 14 01 	lds	r18, 0x0114
    1382:	30 91 15 01 	lds	r19, 0x0115
    1386:	40 91 16 01 	lds	r20, 0x0116
    138a:	50 91 17 01 	lds	r21, 0x0117
    138e:	0e 94 4e 11 	call	0x229c	; 0x229c <__gesf2>
    1392:	18 16       	cp	r1, r24
    1394:	64 f4       	brge	.+24     	; 0x13ae <main_calculations+0x6a6>
    1396:	80 e0       	ldi	r24, 0x00	; 0
    1398:	90 e0       	ldi	r25, 0x00	; 0
    139a:	a0 e2       	ldi	r26, 0x20	; 32
    139c:	b1 e4       	ldi	r27, 0x41	; 65
    139e:	80 93 ac 01 	sts	0x01AC, r24
    13a2:	90 93 ad 01 	sts	0x01AD, r25
    13a6:	a0 93 ae 01 	sts	0x01AE, r26
    13aa:	b0 93 af 01 	sts	0x01AF, r27
	
	
	//if throttle is at or over 50% throttle - adjust time spent in braking
	if ( throttle_percent > 50 )
    13ae:	80 91 ac 01 	lds	r24, 0x01AC
    13b2:	90 91 ad 01 	lds	r25, 0x01AD
    13b6:	a0 91 ae 01 	lds	r26, 0x01AE
    13ba:	b0 91 af 01 	lds	r27, 0x01AF
    13be:	89 83       	std	Y+1, r24	; 0x01
    13c0:	9a 83       	std	Y+2, r25	; 0x02
    13c2:	ab 83       	std	Y+3, r26	; 0x03
    13c4:	bc 83       	std	Y+4, r27	; 0x04
    13c6:	bc 01       	movw	r22, r24
    13c8:	cd 01       	movw	r24, r26
    13ca:	20 e0       	ldi	r18, 0x00	; 0
    13cc:	30 e0       	ldi	r19, 0x00	; 0
    13ce:	48 e4       	ldi	r20, 0x48	; 72
    13d0:	52 e4       	ldi	r21, 0x42	; 66
    13d2:	0e 94 4e 11 	call	0x229c	; 0x229c <__gesf2>
    13d6:	18 16       	cp	r1, r24
    13d8:	0c f0       	brlt	.+2      	; 0x13dc <main_calculations+0x6d4>
    13da:	76 c0       	rjmp	.+236    	; 0x14c8 <main_calculations+0x7c0>
	{                          

		flashy_led = 1;                                        //flash the LED to indicate we're in fast mode
    13dc:	81 e0       	ldi	r24, 0x01	; 1
    13de:	90 e0       	ldi	r25, 0x00	; 0
    13e0:	90 93 a3 01 	sts	0x01A3, r25
    13e4:	80 93 a2 01 	sts	0x01A2, r24

		braking_length = half_spin_time * 25;                  
    13e8:	20 90 8a 01 	lds	r2, 0x018A
    13ec:	30 90 8b 01 	lds	r3, 0x018B
    13f0:	40 90 8c 01 	lds	r4, 0x018C
    13f4:	50 90 8d 01 	lds	r5, 0x018D
    13f8:	c2 01       	movw	r24, r4
    13fa:	b1 01       	movw	r22, r2
    13fc:	20 e0       	ldi	r18, 0x00	; 0
    13fe:	30 e0       	ldi	r19, 0x00	; 0
    1400:	48 ec       	ldi	r20, 0xC8	; 200
    1402:	51 e4       	ldi	r21, 0x41	; 65
    1404:	0e 94 52 11 	call	0x22a4	; 0x22a4 <__mulsf3>
		braking_length = braking_length / throttle_percent;    
    1408:	29 81       	ldd	r18, Y+1	; 0x01
    140a:	3a 81       	ldd	r19, Y+2	; 0x02
    140c:	4b 81       	ldd	r20, Y+3	; 0x03
    140e:	5c 81       	ldd	r21, Y+4	; 0x04
    1410:	0e 94 03 10 	call	0x2006	; 0x2006 <__divsf3>
    1414:	7b 01       	movw	r14, r22
    1416:	8c 01       	movw	r16, r24
    1418:	60 93 60 01 	sts	0x0160, r22
    141c:	70 93 61 01 	sts	0x0161, r23
    1420:	80 93 62 01 	sts	0x0162, r24
    1424:	90 93 63 01 	sts	0x0163, r25

		begin_brake = half_spin_time / 2;
    1428:	c2 01       	movw	r24, r4
    142a:	b1 01       	movw	r22, r2
    142c:	20 e0       	ldi	r18, 0x00	; 0
    142e:	30 e0       	ldi	r19, 0x00	; 0
    1430:	40 e0       	ldi	r20, 0x00	; 0
    1432:	5f e3       	ldi	r21, 0x3F	; 63
    1434:	0e 94 52 11 	call	0x22a4	; 0x22a4 <__mulsf3>
    1438:	5b 01       	movw	r10, r22
    143a:	6c 01       	movw	r12, r24
		begin_brake = begin_brake - braking_length;
    143c:	a8 01       	movw	r20, r16
    143e:	97 01       	movw	r18, r14
    1440:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <__subsf3>
    1444:	3b 01       	movw	r6, r22
    1446:	4c 01       	movw	r8, r24
    1448:	60 93 c2 01 	sts	0x01C2, r22
    144c:	70 93 c3 01 	sts	0x01C3, r23
    1450:	80 93 c4 01 	sts	0x01C4, r24
    1454:	90 93 c5 01 	sts	0x01C5, r25

		end_brake = half_spin_time / 2;
		end_brake = end_brake + braking_length;
    1458:	c6 01       	movw	r24, r12
    145a:	b5 01       	movw	r22, r10
    145c:	a8 01       	movw	r20, r16
    145e:	97 01       	movw	r18, r14
    1460:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <__addsf3>
    1464:	60 93 92 01 	sts	0x0192, r22
    1468:	70 93 93 01 	sts	0x0193, r23
    146c:	80 93 94 01 	sts	0x0194, r24
    1470:	90 93 95 01 	sts	0x0195, r25
	
		if ( begin_brake < 1 )	begin_brake = 1;               //make sure begin_brake isn't getting set to 0
    1474:	c4 01       	movw	r24, r8
    1476:	b3 01       	movw	r22, r6
    1478:	20 e0       	ldi	r18, 0x00	; 0
    147a:	30 e0       	ldi	r19, 0x00	; 0
    147c:	40 e8       	ldi	r20, 0x80	; 128
    147e:	5f e3       	ldi	r21, 0x3F	; 63
    1480:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <__cmpsf2>
    1484:	88 23       	and	r24, r24
    1486:	64 f4       	brge	.+24     	; 0x14a0 <main_calculations+0x798>
    1488:	80 e0       	ldi	r24, 0x00	; 0
    148a:	90 e0       	ldi	r25, 0x00	; 0
    148c:	a0 e8       	ldi	r26, 0x80	; 128
    148e:	bf e3       	ldi	r27, 0x3F	; 63
    1490:	80 93 c2 01 	sts	0x01C2, r24
    1494:	90 93 c3 01 	sts	0x01C3, r25
    1498:	a0 93 c4 01 	sts	0x01C4, r26
    149c:	b0 93 c5 01 	sts	0x01C5, r27
			
		power_kill_part1 = 0;                                  //power_kill not used if throttle over 50%
    14a0:	80 e0       	ldi	r24, 0x00	; 0
    14a2:	90 e0       	ldi	r25, 0x00	; 0
    14a4:	a0 e0       	ldi	r26, 0x00	; 0
    14a6:	b0 e0       	ldi	r27, 0x00	; 0
    14a8:	80 93 82 01 	sts	0x0182, r24
    14ac:	90 93 83 01 	sts	0x0183, r25
    14b0:	a0 93 84 01 	sts	0x0184, r26
    14b4:	b0 93 85 01 	sts	0x0185, r27
		power_kill_part2 = half_spin_time;
    14b8:	20 92 7a 01 	sts	0x017A, r2
    14bc:	30 92 7b 01 	sts	0x017B, r3
    14c0:	40 92 7c 01 	sts	0x017C, r4
    14c4:	50 92 7d 01 	sts	0x017D, r5

	}


	if ( throttle_percent <= 50 )                           //if throttle under 50% - kill the motors for a portion of each spin
    14c8:	69 81       	ldd	r22, Y+1	; 0x01
    14ca:	7a 81       	ldd	r23, Y+2	; 0x02
    14cc:	8b 81       	ldd	r24, Y+3	; 0x03
    14ce:	9c 81       	ldd	r25, Y+4	; 0x04
    14d0:	20 e0       	ldi	r18, 0x00	; 0
    14d2:	30 e0       	ldi	r19, 0x00	; 0
    14d4:	48 e4       	ldi	r20, 0x48	; 72
    14d6:	52 e4       	ldi	r21, 0x42	; 66
    14d8:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <__cmpsf2>
    14dc:	18 16       	cp	r1, r24
    14de:	0c f4       	brge	.+2      	; 0x14e2 <main_calculations+0x7da>
    14e0:	4e c0       	rjmp	.+156    	; 0x157e <main_calculations+0x876>
	{
		begin_brake = 1;
    14e2:	80 e0       	ldi	r24, 0x00	; 0
    14e4:	90 e0       	ldi	r25, 0x00	; 0
    14e6:	a0 e8       	ldi	r26, 0x80	; 128
    14e8:	bf e3       	ldi	r27, 0x3F	; 63
    14ea:	80 93 c2 01 	sts	0x01C2, r24
    14ee:	90 93 c3 01 	sts	0x01C3, r25
    14f2:	a0 93 c4 01 	sts	0x01C4, r26
    14f6:	b0 93 c5 01 	sts	0x01C5, r27
		end_brake = half_spin_time;
    14fa:	e0 90 8a 01 	lds	r14, 0x018A
    14fe:	f0 90 8b 01 	lds	r15, 0x018B
    1502:	00 91 8c 01 	lds	r16, 0x018C
    1506:	10 91 8d 01 	lds	r17, 0x018D
    150a:	e0 92 92 01 	sts	0x0192, r14
    150e:	f0 92 93 01 	sts	0x0193, r15
    1512:	00 93 94 01 	sts	0x0194, r16
    1516:	10 93 95 01 	sts	0x0195, r17

		power_kill_length = 50 - throttle_percent;           //set time in each cycle to cut power (throttling)
		power_kill_length = power_kill_length * half_spin_time;
    151a:	60 e0       	ldi	r22, 0x00	; 0
    151c:	70 e0       	ldi	r23, 0x00	; 0
    151e:	88 e4       	ldi	r24, 0x48	; 72
    1520:	92 e4       	ldi	r25, 0x42	; 66
    1522:	29 81       	ldd	r18, Y+1	; 0x01
    1524:	3a 81       	ldd	r19, Y+2	; 0x02
    1526:	4b 81       	ldd	r20, Y+3	; 0x03
    1528:	5c 81       	ldd	r21, Y+4	; 0x04
    152a:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <__subsf3>
    152e:	a8 01       	movw	r20, r16
    1530:	97 01       	movw	r18, r14
    1532:	0e 94 52 11 	call	0x22a4	; 0x22a4 <__mulsf3>
		power_kill_length = power_kill_length / 150;
    1536:	20 e0       	ldi	r18, 0x00	; 0
    1538:	30 e0       	ldi	r19, 0x00	; 0
    153a:	46 e1       	ldi	r20, 0x16	; 22
    153c:	53 e4       	ldi	r21, 0x43	; 67
    153e:	0e 94 03 10 	call	0x2006	; 0x2006 <__divsf3>
    1542:	9b 01       	movw	r18, r22
    1544:	ac 01       	movw	r20, r24
    1546:	60 93 a8 01 	sts	0x01A8, r22
    154a:	70 93 a9 01 	sts	0x01A9, r23
    154e:	80 93 aa 01 	sts	0x01AA, r24
    1552:	90 93 ab 01 	sts	0x01AB, r25

		power_kill_part1 = power_kill_length;
    1556:	60 93 82 01 	sts	0x0182, r22
    155a:	70 93 83 01 	sts	0x0183, r23
    155e:	80 93 84 01 	sts	0x0184, r24
    1562:	90 93 85 01 	sts	0x0185, r25
		power_kill_part2 = half_spin_time - power_kill_length;
    1566:	c8 01       	movw	r24, r16
    1568:	b7 01       	movw	r22, r14
    156a:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <__subsf3>
    156e:	60 93 7a 01 	sts	0x017A, r22
    1572:	70 93 7b 01 	sts	0x017B, r23
    1576:	80 93 7c 01 	sts	0x017C, r24
    157a:	90 93 7d 01 	sts	0x017D, r25

	}

	if ( full_power_spin == 1 )      //if we're actually doing full power this spin (no translation) - ignore any calculations / reset variables
    157e:	80 91 bc 01 	lds	r24, 0x01BC
    1582:	90 91 bd 01 	lds	r25, 0x01BD
    1586:	01 97       	sbiw	r24, 0x01	; 1
    1588:	81 f5       	brne	.+96     	; 0x15ea <main_calculations+0x8e2>
	{
		end_brake = 1;
    158a:	80 e0       	ldi	r24, 0x00	; 0
    158c:	90 e0       	ldi	r25, 0x00	; 0
    158e:	a0 e8       	ldi	r26, 0x80	; 128
    1590:	bf e3       	ldi	r27, 0x3F	; 63
    1592:	80 93 92 01 	sts	0x0192, r24
    1596:	90 93 93 01 	sts	0x0193, r25
    159a:	a0 93 94 01 	sts	0x0194, r26
    159e:	b0 93 95 01 	sts	0x0195, r27
		begin_brake = 0;
    15a2:	80 e0       	ldi	r24, 0x00	; 0
    15a4:	90 e0       	ldi	r25, 0x00	; 0
    15a6:	a0 e0       	ldi	r26, 0x00	; 0
    15a8:	b0 e0       	ldi	r27, 0x00	; 0
    15aa:	80 93 c2 01 	sts	0x01C2, r24
    15ae:	90 93 c3 01 	sts	0x01C3, r25
    15b2:	a0 93 c4 01 	sts	0x01C4, r26
    15b6:	b0 93 c5 01 	sts	0x01C5, r27

		power_kill_part1 = 0;
    15ba:	80 93 82 01 	sts	0x0182, r24
    15be:	90 93 83 01 	sts	0x0183, r25
    15c2:	a0 93 84 01 	sts	0x0184, r26
    15c6:	b0 93 85 01 	sts	0x0185, r27
		power_kill_part2 = half_spin_time;
    15ca:	80 91 8a 01 	lds	r24, 0x018A
    15ce:	90 91 8b 01 	lds	r25, 0x018B
    15d2:	a0 91 8c 01 	lds	r26, 0x018C
    15d6:	b0 91 8d 01 	lds	r27, 0x018D
    15da:	80 93 7a 01 	sts	0x017A, r24
    15de:	90 93 7b 01 	sts	0x017B, r25
    15e2:	a0 93 7c 01 	sts	0x017C, r26
    15e6:	b0 93 7d 01 	sts	0x017D, r27
	}
	
	if (in_config_mode == 1) config_mode();	//do config_mode stuff if we're in configuration mode
    15ea:	ad 81       	ldd	r26, Y+5	; 0x05
    15ec:	be 81       	ldd	r27, Y+6	; 0x06
    15ee:	11 97       	sbiw	r26, 0x01	; 1
    15f0:	11 f4       	brne	.+4      	; 0x15f6 <main_calculations+0x8ee>
    15f2:	0e 94 d3 00 	call	0x1a6	; 0x1a6 <config_mode>
		
	//adjustments - convert times from milliseconds to timer ticks
	led_on = led_on * 312.5;
    15f6:	60 91 96 01 	lds	r22, 0x0196
    15fa:	70 91 97 01 	lds	r23, 0x0197
    15fe:	80 91 98 01 	lds	r24, 0x0198
    1602:	90 91 99 01 	lds	r25, 0x0199
    1606:	20 e0       	ldi	r18, 0x00	; 0
    1608:	30 e4       	ldi	r19, 0x40	; 64
    160a:	4c e9       	ldi	r20, 0x9C	; 156
    160c:	53 e4       	ldi	r21, 0x43	; 67
    160e:	0e 94 52 11 	call	0x22a4	; 0x22a4 <__mulsf3>
    1612:	60 93 96 01 	sts	0x0196, r22
    1616:	70 93 97 01 	sts	0x0197, r23
    161a:	80 93 98 01 	sts	0x0198, r24
    161e:	90 93 99 01 	sts	0x0199, r25
	led_off = led_off * 312.5;
    1622:	60 91 b8 01 	lds	r22, 0x01B8
    1626:	70 91 b9 01 	lds	r23, 0x01B9
    162a:	80 91 ba 01 	lds	r24, 0x01BA
    162e:	90 91 bb 01 	lds	r25, 0x01BB
    1632:	20 e0       	ldi	r18, 0x00	; 0
    1634:	30 e4       	ldi	r19, 0x40	; 64
    1636:	4c e9       	ldi	r20, 0x9C	; 156
    1638:	53 e4       	ldi	r21, 0x43	; 67
    163a:	0e 94 52 11 	call	0x22a4	; 0x22a4 <__mulsf3>
    163e:	60 93 b8 01 	sts	0x01B8, r22
    1642:	70 93 b9 01 	sts	0x01B9, r23
    1646:	80 93 ba 01 	sts	0x01BA, r24
    164a:	90 93 bb 01 	sts	0x01BB, r25
	half_spin_time = half_spin_time * 312.5;
    164e:	60 91 8a 01 	lds	r22, 0x018A
    1652:	70 91 8b 01 	lds	r23, 0x018B
    1656:	80 91 8c 01 	lds	r24, 0x018C
    165a:	90 91 8d 01 	lds	r25, 0x018D
    165e:	20 e0       	ldi	r18, 0x00	; 0
    1660:	30 e4       	ldi	r19, 0x40	; 64
    1662:	4c e9       	ldi	r20, 0x9C	; 156
    1664:	53 e4       	ldi	r21, 0x43	; 67
    1666:	0e 94 52 11 	call	0x22a4	; 0x22a4 <__mulsf3>
    166a:	60 93 8a 01 	sts	0x018A, r22
    166e:	70 93 8b 01 	sts	0x018B, r23
    1672:	80 93 8c 01 	sts	0x018C, r24
    1676:	90 93 8d 01 	sts	0x018D, r25
	power_kill_part1 = power_kill_part1 * 312.5;
    167a:	60 91 82 01 	lds	r22, 0x0182
    167e:	70 91 83 01 	lds	r23, 0x0183
    1682:	80 91 84 01 	lds	r24, 0x0184
    1686:	90 91 85 01 	lds	r25, 0x0185
    168a:	20 e0       	ldi	r18, 0x00	; 0
    168c:	30 e4       	ldi	r19, 0x40	; 64
    168e:	4c e9       	ldi	r20, 0x9C	; 156
    1690:	53 e4       	ldi	r21, 0x43	; 67
    1692:	0e 94 52 11 	call	0x22a4	; 0x22a4 <__mulsf3>
    1696:	60 93 82 01 	sts	0x0182, r22
    169a:	70 93 83 01 	sts	0x0183, r23
    169e:	80 93 84 01 	sts	0x0184, r24
    16a2:	90 93 85 01 	sts	0x0185, r25
	power_kill_part2 = power_kill_part2 * 312.5;
    16a6:	60 91 7a 01 	lds	r22, 0x017A
    16aa:	70 91 7b 01 	lds	r23, 0x017B
    16ae:	80 91 7c 01 	lds	r24, 0x017C
    16b2:	90 91 7d 01 	lds	r25, 0x017D
    16b6:	20 e0       	ldi	r18, 0x00	; 0
    16b8:	30 e4       	ldi	r19, 0x40	; 64
    16ba:	4c e9       	ldi	r20, 0x9C	; 156
    16bc:	53 e4       	ldi	r21, 0x43	; 67
    16be:	0e 94 52 11 	call	0x22a4	; 0x22a4 <__mulsf3>
    16c2:	60 93 7a 01 	sts	0x017A, r22
    16c6:	70 93 7b 01 	sts	0x017B, r23
    16ca:	80 93 7c 01 	sts	0x017C, r24
    16ce:	90 93 7d 01 	sts	0x017D, r25
	begin_brake = begin_brake * 312.5;
    16d2:	60 91 c2 01 	lds	r22, 0x01C2
    16d6:	70 91 c3 01 	lds	r23, 0x01C3
    16da:	80 91 c4 01 	lds	r24, 0x01C4
    16de:	90 91 c5 01 	lds	r25, 0x01C5
    16e2:	20 e0       	ldi	r18, 0x00	; 0
    16e4:	30 e4       	ldi	r19, 0x40	; 64
    16e6:	4c e9       	ldi	r20, 0x9C	; 156
    16e8:	53 e4       	ldi	r21, 0x43	; 67
    16ea:	0e 94 52 11 	call	0x22a4	; 0x22a4 <__mulsf3>
    16ee:	60 93 c2 01 	sts	0x01C2, r22
    16f2:	70 93 c3 01 	sts	0x01C3, r23
    16f6:	80 93 c4 01 	sts	0x01C4, r24
    16fa:	90 93 c5 01 	sts	0x01C5, r25
	end_brake = end_brake * 312.5;
    16fe:	60 91 92 01 	lds	r22, 0x0192
    1702:	70 91 93 01 	lds	r23, 0x0193
    1706:	80 91 94 01 	lds	r24, 0x0194
    170a:	90 91 95 01 	lds	r25, 0x0195
    170e:	20 e0       	ldi	r18, 0x00	; 0
    1710:	30 e4       	ldi	r19, 0x40	; 64
    1712:	4c e9       	ldi	r20, 0x9C	; 156
    1714:	53 e4       	ldi	r21, 0x43	; 67
    1716:	0e 94 52 11 	call	0x22a4	; 0x22a4 <__mulsf3>
    171a:	60 93 92 01 	sts	0x0192, r22
    171e:	70 93 93 01 	sts	0x0193, r23
    1722:	80 93 94 01 	sts	0x0194, r24
    1726:	90 93 95 01 	sts	0x0195, r25

	sei();  //enable interrupts to allow updating of transmitter data - out of all the critical stuff
    172a:	78 94       	sei
	

}
    172c:	26 96       	adiw	r28, 0x06	; 6
    172e:	0f b6       	in	r0, 0x3f	; 63
    1730:	f8 94       	cli
    1732:	de bf       	out	0x3e, r29	; 62
    1734:	0f be       	out	0x3f, r0	; 63
    1736:	cd bf       	out	0x3d, r28	; 61
    1738:	cf 91       	pop	r28
    173a:	df 91       	pop	r29
    173c:	1f 91       	pop	r17
    173e:	0f 91       	pop	r16
    1740:	ff 90       	pop	r15
    1742:	ef 90       	pop	r14
    1744:	df 90       	pop	r13
    1746:	cf 90       	pop	r12
    1748:	bf 90       	pop	r11
    174a:	af 90       	pop	r10
    174c:	9f 90       	pop	r9
    174e:	8f 90       	pop	r8
    1750:	7f 90       	pop	r7
    1752:	6f 90       	pop	r6
    1754:	5f 90       	pop	r5
    1756:	4f 90       	pop	r4
    1758:	3f 90       	pop	r3
    175a:	2f 90       	pop	r2
    175c:	08 95       	ret

0000175e <save_config>:
	}

}

void save_config(void)
{
    175e:	6f 92       	push	r6
    1760:	7f 92       	push	r7
    1762:	8f 92       	push	r8
    1764:	9f 92       	push	r9
    1766:	af 92       	push	r10
    1768:	bf 92       	push	r11
    176a:	cf 92       	push	r12
    176c:	df 92       	push	r13
    176e:	ef 92       	push	r14
    1770:	ff 92       	push	r15
    1772:	0f 93       	push	r16
    1774:	1f 93       	push	r17
	long tracking_word1;	//first word of tracking_comp
	float tracking_word2;	//second word of tracking_comp
	
	//this code busts up tracking_comp (float) into two words for storage to ROM (there are probably cleaner ways to do this)
	
	tracking_word1 = tracking_comp * 1000;							//mulitply tracking_comp by 1000 to get 1st word
    1776:	60 91 2c 01 	lds	r22, 0x012C
    177a:	70 91 2d 01 	lds	r23, 0x012D
    177e:	80 91 2e 01 	lds	r24, 0x012E
    1782:	90 91 2f 01 	lds	r25, 0x012F
    1786:	20 e0       	ldi	r18, 0x00	; 0
    1788:	30 e0       	ldi	r19, 0x00	; 0
    178a:	4a e7       	ldi	r20, 0x7A	; 122
    178c:	54 e4       	ldi	r21, 0x44	; 68
    178e:	0e 94 52 11 	call	0x22a4	; 0x22a4 <__mulsf3>
    1792:	7b 01       	movw	r14, r22
    1794:	8c 01       	movw	r16, r24
    1796:	0e 94 6b 10 	call	0x20d6	; 0x20d6 <__fixsfsi>
    179a:	5b 01       	movw	r10, r22
    179c:	6c 01       	movw	r12, r24
	tracking_word2 = ((tracking_comp * 1000) - tracking_word1);	//amount that didn't make it into word1 goes into word2
    179e:	0e 94 9e 10 	call	0x213c	; 0x213c <__floatsisf>
    17a2:	9b 01       	movw	r18, r22
    17a4:	ac 01       	movw	r20, r24
    17a6:	c8 01       	movw	r24, r16
    17a8:	b7 01       	movw	r22, r14
    17aa:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <__subsf3>
    17ae:	3b 01       	movw	r6, r22
    17b0:	4c 01       	movw	r8, r24
    Write a word \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_word (uint16_t *__p, uint16_t __value)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_word (__p, __value, eeprom_write_byte);
    17b2:	0b e5       	ldi	r16, 0x5B	; 91
    17b4:	10 e0       	ldi	r17, 0x00	; 0
    17b6:	80 e0       	ldi	r24, 0x00	; 0
    17b8:	90 e0       	ldi	r25, 0x00	; 0
    17ba:	60 e8       	ldi	r22, 0x80	; 128
    17bc:	70 e0       	ldi	r23, 0x00	; 0
    17be:	a8 01       	movw	r20, r16
    17c0:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <__eewr_word>
	eeprom_write_word(&tracking_comp_save_word2, tracking_word2);	//saves out tracking calibration word2 (converted to integer)
	eeprom_write_word(&heading_center_save, heading_center);	//saves out RC center value for left/right 
	eeprom_write_word(&base_accel_save, base_accel);	//saves out accelerometer 0G value


}
    17c4:	60 91 30 01 	lds	r22, 0x0130
    17c8:	70 91 31 01 	lds	r23, 0x0131
    17cc:	80 91 32 01 	lds	r24, 0x0132
    17d0:	90 91 33 01 	lds	r25, 0x0133
    17d4:	0e 94 70 10 	call	0x20e0	; 0x20e0 <__fixunssfsi>
    17d8:	9b 01       	movw	r18, r22
    17da:	ac 01       	movw	r20, r24
    17dc:	82 e0       	ldi	r24, 0x02	; 2
    17de:	90 e0       	ldi	r25, 0x00	; 0
    17e0:	b9 01       	movw	r22, r18
    17e2:	a8 01       	movw	r20, r16
    17e4:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <__eewr_word>
    17e8:	84 e0       	ldi	r24, 0x04	; 4
    17ea:	90 e0       	ldi	r25, 0x00	; 0
    17ec:	b5 01       	movw	r22, r10
    17ee:	a8 01       	movw	r20, r16
    17f0:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <__eewr_word>
    17f4:	c4 01       	movw	r24, r8
    17f6:	b3 01       	movw	r22, r6
    17f8:	20 e0       	ldi	r18, 0x00	; 0
    17fa:	30 e4       	ldi	r19, 0x40	; 64
    17fc:	4c e1       	ldi	r20, 0x1C	; 28
    17fe:	56 e4       	ldi	r21, 0x46	; 70
    1800:	0e 94 52 11 	call	0x22a4	; 0x22a4 <__mulsf3>
    1804:	0e 94 70 10 	call	0x20e0	; 0x20e0 <__fixunssfsi>
    1808:	9b 01       	movw	r18, r22
    180a:	ac 01       	movw	r20, r24
    180c:	86 e0       	ldi	r24, 0x06	; 6
    180e:	90 e0       	ldi	r25, 0x00	; 0
    1810:	b9 01       	movw	r22, r18
    1812:	a8 01       	movw	r20, r16
    1814:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <__eewr_word>
    1818:	60 91 0a 01 	lds	r22, 0x010A
    181c:	70 91 0b 01 	lds	r23, 0x010B
    1820:	88 e0       	ldi	r24, 0x08	; 8
    1822:	90 e0       	ldi	r25, 0x00	; 0
    1824:	a8 01       	movw	r20, r16
    1826:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <__eewr_word>
    182a:	60 91 34 01 	lds	r22, 0x0134
    182e:	70 91 35 01 	lds	r23, 0x0135
    1832:	8a e0       	ldi	r24, 0x0A	; 10
    1834:	90 e0       	ldi	r25, 0x00	; 0
    1836:	a8 01       	movw	r20, r16
    1838:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <__eewr_word>
    183c:	1f 91       	pop	r17
    183e:	0f 91       	pop	r16
    1840:	ff 90       	pop	r15
    1842:	ef 90       	pop	r14
    1844:	df 90       	pop	r13
    1846:	cf 90       	pop	r12
    1848:	bf 90       	pop	r11
    184a:	af 90       	pop	r10
    184c:	9f 90       	pop	r9
    184e:	8f 90       	pop	r8
    1850:	7f 90       	pop	r7
    1852:	6f 90       	pop	r6
    1854:	08 95       	ret

00001856 <safety_and_idle>:
}



void safety_and_idle(void)
{
    1856:	2f 92       	push	r2
    1858:	3f 92       	push	r3
    185a:	4f 92       	push	r4
    185c:	5f 92       	push	r5
    185e:	6f 92       	push	r6
    1860:	7f 92       	push	r7
    1862:	8f 92       	push	r8
    1864:	9f 92       	push	r9
    1866:	af 92       	push	r10
    1868:	bf 92       	push	r11
    186a:	cf 92       	push	r12
    186c:	df 92       	push	r13
    186e:	ef 92       	push	r14
    1870:	ff 92       	push	r15
    1872:	0f 93       	push	r16
    1874:	1f 93       	push	r17
    1876:	cf 93       	push	r28
    1878:	df 93       	push	r29
	
	sei();  //enable interrupts (needed to get transmitter data)
    187a:	78 94       	sei
    187c:	c4 ef       	ldi	r28, 0xF4	; 244
    187e:	d1 e0       	ldi	r29, 0x01	; 1
		{

			_delay_ms(10);
			if (forwardback > (forwardback_center + forwardback_backthresh) && forwardback < (forwardback_center + forwardback_forwardthresh))	//check it again to be sure
			{
				got_centered_forwardback = 1;
    1880:	a0 e5       	ldi	r26, 0x50	; 80
    1882:	4a 2e       	mov	r4, r26
    1884:	a3 ec       	ldi	r26, 0xC3	; 195
    1886:	5a 2e       	mov	r5, r26
    1888:	f1 e0       	ldi	r31, 0x01	; 1
    188a:	2f 2e       	mov	r2, r31
    188c:	31 2c       	mov	r3, r1
    188e:	fb c1       	rjmp	.+1014   	; 0x1c86 <safety_and_idle+0x430>
}


void motors_off(void)
{
	set_motor1_off();
    1890:	5a 98       	cbi	0x0b, 2	; 11
	set_motor2_off();
    1892:	5c 98       	cbi	0x0b, 4	; 11
	{


		motors_off();			//motors are off while sitting idle

		if (throttle < throttle_low || throttle > (throttle_high + 100)) throttle_up_count = 0;		//single low / bad throttle resets the counter to 0
    1894:	80 91 86 01 	lds	r24, 0x0186
    1898:	90 91 87 01 	lds	r25, 0x0187
    189c:	a0 91 88 01 	lds	r26, 0x0188
    18a0:	b0 91 89 01 	lds	r27, 0x0189
    18a4:	8e 15       	cp	r24, r14
    18a6:	9f 05       	cpc	r25, r15
    18a8:	a0 07       	cpc	r26, r16
    18aa:	b1 07       	cpc	r27, r17
    18ac:	bc f0       	brlt	.+46     	; 0x18dc <safety_and_idle+0x86>
    18ae:	20 91 86 01 	lds	r18, 0x0186
    18b2:	30 91 87 01 	lds	r19, 0x0187
    18b6:	40 91 88 01 	lds	r20, 0x0188
    18ba:	50 91 89 01 	lds	r21, 0x0189
    18be:	80 91 02 01 	lds	r24, 0x0102
    18c2:	90 91 03 01 	lds	r25, 0x0103
    18c6:	8c 59       	subi	r24, 0x9C	; 156
    18c8:	9f 4f       	sbci	r25, 0xFF	; 255
    18ca:	aa 27       	eor	r26, r26
    18cc:	97 fd       	sbrc	r25, 7
    18ce:	a0 95       	com	r26
    18d0:	ba 2f       	mov	r27, r26
    18d2:	82 17       	cp	r24, r18
    18d4:	93 07       	cpc	r25, r19
    18d6:	a4 07       	cpc	r26, r20
    18d8:	b5 07       	cpc	r27, r21
    18da:	24 f4       	brge	.+8      	; 0x18e4 <safety_and_idle+0x8e>
    18dc:	10 92 45 01 	sts	0x0145, r1
    18e0:	10 92 44 01 	sts	0x0144, r1
		if (throttle > throttle_low && throttle < (throttle_high + 100)) throttle_up_count ++;		//if the throttle has been moved high - increment the counter
    18e4:	80 91 86 01 	lds	r24, 0x0186
    18e8:	90 91 87 01 	lds	r25, 0x0187
    18ec:	a0 91 88 01 	lds	r26, 0x0188
    18f0:	b0 91 89 01 	lds	r27, 0x0189
    18f4:	e8 16       	cp	r14, r24
    18f6:	f9 06       	cpc	r15, r25
    18f8:	0a 07       	cpc	r16, r26
    18fa:	1b 07       	cpc	r17, r27
    18fc:	04 f5       	brge	.+64     	; 0x193e <safety_and_idle+0xe8>
    18fe:	20 91 86 01 	lds	r18, 0x0186
    1902:	30 91 87 01 	lds	r19, 0x0187
    1906:	40 91 88 01 	lds	r20, 0x0188
    190a:	50 91 89 01 	lds	r21, 0x0189
    190e:	80 91 02 01 	lds	r24, 0x0102
    1912:	90 91 03 01 	lds	r25, 0x0103
    1916:	8c 59       	subi	r24, 0x9C	; 156
    1918:	9f 4f       	sbci	r25, 0xFF	; 255
    191a:	aa 27       	eor	r26, r26
    191c:	97 fd       	sbrc	r25, 7
    191e:	a0 95       	com	r26
    1920:	ba 2f       	mov	r27, r26
    1922:	28 17       	cp	r18, r24
    1924:	39 07       	cpc	r19, r25
    1926:	4a 07       	cpc	r20, r26
    1928:	5b 07       	cpc	r21, r27
    192a:	4c f4       	brge	.+18     	; 0x193e <safety_and_idle+0xe8>
    192c:	80 91 44 01 	lds	r24, 0x0144
    1930:	90 91 45 01 	lds	r25, 0x0145
    1934:	01 96       	adiw	r24, 0x01	; 1
    1936:	90 93 45 01 	sts	0x0145, r25
    193a:	80 93 44 01 	sts	0x0144, r24

		//interrupt blinking if stick isn't centered (helps to verify TX is working)
		if ( leftright > (heading_center + heading_leftthresh) ) {set_led_on(); _delay_ms(200);}
    193e:	20 91 8e 01 	lds	r18, 0x018E
    1942:	30 91 8f 01 	lds	r19, 0x018F
    1946:	40 91 90 01 	lds	r20, 0x0190
    194a:	50 91 91 01 	lds	r21, 0x0191
    194e:	60 91 0a 01 	lds	r22, 0x010A
    1952:	70 91 0b 01 	lds	r23, 0x010B
    1956:	80 91 0c 01 	lds	r24, 0x010C
    195a:	90 91 0d 01 	lds	r25, 0x010D
    195e:	86 0f       	add	r24, r22
    1960:	97 1f       	adc	r25, r23
    1962:	aa 27       	eor	r26, r26
    1964:	97 fd       	sbrc	r25, 7
    1966:	a0 95       	com	r26
    1968:	ba 2f       	mov	r27, r26
    196a:	82 17       	cp	r24, r18
    196c:	93 07       	cpc	r25, r19
    196e:	a4 07       	cpc	r26, r20
    1970:	b5 07       	cpc	r27, r21
    1972:	44 f4       	brge	.+16     	; 0x1984 <safety_and_idle+0x12e>
    1974:	5d 9a       	sbi	0x0b, 5	; 11
    1976:	80 ed       	ldi	r24, 0xD0	; 208
    1978:	97 e0       	ldi	r25, 0x07	; 7
    197a:	fe 01       	movw	r30, r28
    197c:	31 97       	sbiw	r30, 0x01	; 1
    197e:	f1 f7       	brne	.-4      	; 0x197c <safety_and_idle+0x126>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1980:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1982:	d9 f7       	brne	.-10     	; 0x197a <safety_and_idle+0x124>
		if ( leftright < (heading_center + heading_rightthresh) ) {set_led_on(); _delay_ms(200);}
    1984:	20 91 8e 01 	lds	r18, 0x018E
    1988:	30 91 8f 01 	lds	r19, 0x018F
    198c:	40 91 90 01 	lds	r20, 0x0190
    1990:	50 91 91 01 	lds	r21, 0x0191
    1994:	80 91 0e 01 	lds	r24, 0x010E
    1998:	90 91 0f 01 	lds	r25, 0x010F
    199c:	68 0f       	add	r22, r24
    199e:	79 1f       	adc	r23, r25
    19a0:	cb 01       	movw	r24, r22
    19a2:	aa 27       	eor	r26, r26
    19a4:	97 fd       	sbrc	r25, 7
    19a6:	a0 95       	com	r26
    19a8:	ba 2f       	mov	r27, r26
    19aa:	28 17       	cp	r18, r24
    19ac:	39 07       	cpc	r19, r25
    19ae:	4a 07       	cpc	r20, r26
    19b0:	5b 07       	cpc	r21, r27
    19b2:	44 f4       	brge	.+16     	; 0x19c4 <safety_and_idle+0x16e>
    19b4:	5d 9a       	sbi	0x0b, 5	; 11
    19b6:	80 ed       	ldi	r24, 0xD0	; 208
    19b8:	97 e0       	ldi	r25, 0x07	; 7
    19ba:	fe 01       	movw	r30, r28
    19bc:	31 97       	sbiw	r30, 0x01	; 1
    19be:	f1 f7       	brne	.-4      	; 0x19bc <safety_and_idle+0x166>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    19c0:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    19c2:	d9 f7       	brne	.-10     	; 0x19ba <safety_and_idle+0x164>

		//sit there and flash LED
		
		toggle_led();
    19c4:	8b b1       	in	r24, 0x0b	; 11
    19c6:	90 e2       	ldi	r25, 0x20	; 32
    19c8:	89 27       	eor	r24, r25
    19ca:	8b b9       	out	0x0b, r24	; 11
    19cc:	8c e2       	ldi	r24, 0x2C	; 44
    19ce:	91 e0       	ldi	r25, 0x01	; 1
    19d0:	fe 01       	movw	r30, r28
    19d2:	31 97       	sbiw	r30, 0x01	; 1
    19d4:	f1 f7       	brne	.-4      	; 0x19d2 <safety_and_idle+0x17c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    19d6:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    19d8:	d9 f7       	brne	.-10     	; 0x19d0 <safety_and_idle+0x17a>
		_delay_ms(30);		
		

		//slower LED flash if in config mode
		if (in_config_mode == 1) {set_led_off(); _delay_ms(200);}		
    19da:	80 90 c0 01 	lds	r8, 0x01C0
    19de:	90 90 c1 01 	lds	r9, 0x01C1
    19e2:	81 e0       	ldi	r24, 0x01	; 1
    19e4:	88 16       	cp	r8, r24
    19e6:	91 04       	cpc	r9, r1
    19e8:	41 f4       	brne	.+16     	; 0x19fa <safety_and_idle+0x1a4>
    19ea:	5d 98       	cbi	0x0b, 5	; 11
    19ec:	80 ed       	ldi	r24, 0xD0	; 208
    19ee:	97 e0       	ldi	r25, 0x07	; 7
    19f0:	fe 01       	movw	r30, r28
    19f2:	31 97       	sbiw	r30, 0x01	; 1
    19f4:	f1 f7       	brne	.-4      	; 0x19f2 <safety_and_idle+0x19c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    19f6:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    19f8:	d9 f7       	brne	.-10     	; 0x19f0 <safety_and_idle+0x19a>
		
		
		//verifies we got a centered forwardback stick at least once before allowing config mode (prevents boot directly into config mode if fail-safe is below center)
		if (forwardback > (forwardback_center + forwardback_backthresh) && forwardback < (forwardback_center + forwardback_forwardthresh))
    19fa:	20 91 6c 01 	lds	r18, 0x016C
    19fe:	30 91 6d 01 	lds	r19, 0x016D
    1a02:	40 91 6e 01 	lds	r20, 0x016E
    1a06:	50 91 6f 01 	lds	r21, 0x016F
    1a0a:	60 91 04 01 	lds	r22, 0x0104
    1a0e:	70 91 05 01 	lds	r23, 0x0105
    1a12:	80 91 08 01 	lds	r24, 0x0108
    1a16:	90 91 09 01 	lds	r25, 0x0109
    1a1a:	86 0f       	add	r24, r22
    1a1c:	97 1f       	adc	r25, r23
    1a1e:	7c 01       	movw	r14, r24
    1a20:	00 27       	eor	r16, r16
    1a22:	f7 fc       	sbrc	r15, 7
    1a24:	00 95       	com	r16
    1a26:	10 2f       	mov	r17, r16
    1a28:	e2 16       	cp	r14, r18
    1a2a:	f3 06       	cpc	r15, r19
    1a2c:	04 07       	cpc	r16, r20
    1a2e:	15 07       	cpc	r17, r21
    1a30:	cc f5       	brge	.+114    	; 0x1aa4 <safety_and_idle+0x24e>
    1a32:	20 91 6c 01 	lds	r18, 0x016C
    1a36:	30 91 6d 01 	lds	r19, 0x016D
    1a3a:	40 91 6e 01 	lds	r20, 0x016E
    1a3e:	50 91 6f 01 	lds	r21, 0x016F
    1a42:	80 91 06 01 	lds	r24, 0x0106
    1a46:	90 91 07 01 	lds	r25, 0x0107
    1a4a:	68 0f       	add	r22, r24
    1a4c:	79 1f       	adc	r23, r25
    1a4e:	5b 01       	movw	r10, r22
    1a50:	cc 24       	eor	r12, r12
    1a52:	b7 fc       	sbrc	r11, 7
    1a54:	c0 94       	com	r12
    1a56:	dc 2c       	mov	r13, r12
    1a58:	2a 15       	cp	r18, r10
    1a5a:	3b 05       	cpc	r19, r11
    1a5c:	4c 05       	cpc	r20, r12
    1a5e:	5d 05       	cpc	r21, r13
    1a60:	0c f5       	brge	.+66     	; 0x1aa4 <safety_and_idle+0x24e>
    1a62:	c2 01       	movw	r24, r4
    1a64:	01 97       	sbiw	r24, 0x01	; 1
    1a66:	f1 f7       	brne	.-4      	; 0x1a64 <safety_and_idle+0x20e>
		{

			_delay_ms(10);
			if (forwardback > (forwardback_center + forwardback_backthresh) && forwardback < (forwardback_center + forwardback_forwardthresh))	//check it again to be sure
    1a68:	80 91 6c 01 	lds	r24, 0x016C
    1a6c:	90 91 6d 01 	lds	r25, 0x016D
    1a70:	a0 91 6e 01 	lds	r26, 0x016E
    1a74:	b0 91 6f 01 	lds	r27, 0x016F
    1a78:	e8 16       	cp	r14, r24
    1a7a:	f9 06       	cpc	r15, r25
    1a7c:	0a 07       	cpc	r16, r26
    1a7e:	1b 07       	cpc	r17, r27
    1a80:	8c f4       	brge	.+34     	; 0x1aa4 <safety_and_idle+0x24e>
    1a82:	80 91 6c 01 	lds	r24, 0x016C
    1a86:	90 91 6d 01 	lds	r25, 0x016D
    1a8a:	a0 91 6e 01 	lds	r26, 0x016E
    1a8e:	b0 91 6f 01 	lds	r27, 0x016F
    1a92:	8a 15       	cp	r24, r10
    1a94:	9b 05       	cpc	r25, r11
    1a96:	ac 05       	cpc	r26, r12
    1a98:	bd 05       	cpc	r27, r13
    1a9a:	24 f4       	brge	.+8      	; 0x1aa4 <safety_and_idle+0x24e>
			{
				got_centered_forwardback = 1;
    1a9c:	30 92 41 01 	sts	0x0141, r3
    1aa0:	20 92 40 01 	sts	0x0140, r2
			}
		}
 

		//check for enter / leave config mode
		if (forwardback < (forwardback_center + forwardback_backthresh) && got_centered_forwardback == 1)		//is the stick being held back?
    1aa4:	80 91 6c 01 	lds	r24, 0x016C
    1aa8:	90 91 6d 01 	lds	r25, 0x016D
    1aac:	a0 91 6e 01 	lds	r26, 0x016E
    1ab0:	b0 91 6f 01 	lds	r27, 0x016F
    1ab4:	8e 15       	cp	r24, r14
    1ab6:	9f 05       	cpc	r25, r15
    1ab8:	a0 07       	cpc	r26, r16
    1aba:	b1 07       	cpc	r27, r17
    1abc:	0c f0       	brlt	.+2      	; 0x1ac0 <safety_and_idle+0x26a>
    1abe:	98 c0       	rjmp	.+304    	; 0x1bf0 <safety_and_idle+0x39a>
    1ac0:	80 91 40 01 	lds	r24, 0x0140
    1ac4:	90 91 41 01 	lds	r25, 0x0141
    1ac8:	01 97       	sbiw	r24, 0x01	; 1
    1aca:	09 f0       	breq	.+2      	; 0x1ace <safety_and_idle+0x278>
    1acc:	91 c0       	rjmp	.+290    	; 0x1bf0 <safety_and_idle+0x39a>
    1ace:	80 e1       	ldi	r24, 0x10	; 16
    1ad0:	97 e2       	ldi	r25, 0x27	; 39
    1ad2:	fe 01       	movw	r30, r28
    1ad4:	31 97       	sbiw	r30, 0x01	; 1
    1ad6:	f1 f7       	brne	.-4      	; 0x1ad4 <safety_and_idle+0x27e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1ad8:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1ada:	d9 f7       	brne	.-10     	; 0x1ad2 <safety_and_idle+0x27c>
		{

			//wait a bit to make sure stick is being held...
			_delay_ms(1000);
			//still being held back - then enter / leave config mode
			if (forwardback < (forwardback_center + forwardback_backthresh))
    1adc:	80 91 6c 01 	lds	r24, 0x016C
    1ae0:	90 91 6d 01 	lds	r25, 0x016D
    1ae4:	a0 91 6e 01 	lds	r26, 0x016E
    1ae8:	b0 91 6f 01 	lds	r27, 0x016F
    1aec:	8e 15       	cp	r24, r14
    1aee:	9f 05       	cpc	r25, r15
    1af0:	a0 07       	cpc	r26, r16
    1af2:	b1 07       	cpc	r27, r17
    1af4:	0c f0       	brlt	.+2      	; 0x1af8 <safety_and_idle+0x2a2>
    1af6:	7c c0       	rjmp	.+248    	; 0x1bf0 <safety_and_idle+0x39a>
			{
				in_config_mode = !in_config_mode;
    1af8:	20 e0       	ldi	r18, 0x00	; 0
    1afa:	30 e0       	ldi	r19, 0x00	; 0
    1afc:	89 28       	or	r8, r9
    1afe:	11 f4       	brne	.+4      	; 0x1b04 <safety_and_idle+0x2ae>
    1b00:	21 e0       	ldi	r18, 0x01	; 1
    1b02:	30 e0       	ldi	r19, 0x00	; 0
    1b04:	30 93 c1 01 	sts	0x01C1, r19
    1b08:	20 93 c0 01 	sts	0x01C0, r18
    1b0c:	88 e9       	ldi	r24, 0x98	; 152
    1b0e:	9a e3       	ldi	r25, 0x3A	; 58
    1b10:	fe 01       	movw	r30, r28
    1b12:	31 97       	sbiw	r30, 0x01	; 1
    1b14:	f1 f7       	brne	.-4      	; 0x1b12 <safety_and_idle+0x2bc>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1b16:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1b18:	d9 f7       	brne	.-10     	; 0x1b10 <safety_and_idle+0x2ba>
				_delay_ms(1500);				//delay a bit longer to help assure config_mode isn't toggled again

				cli();                	//disable interrupts - seems like a good idea before saving stuff to ROM
    1b1a:	f8 94       	cli
				if (in_config_mode == 1) get_config_constants();		//read + set a few constants prior to actually going into config mode
    1b1c:	21 30       	cpi	r18, 0x01	; 1
    1b1e:	31 05       	cpc	r19, r1
    1b20:	11 f4       	brne	.+4      	; 0x1b26 <safety_and_idle+0x2d0>
    1b22:	0e 94 68 00 	call	0xd0	; 0xd0 <get_config_constants>
				if (in_config_mode == 0) save_config();				//if we're exiting config mode - save the configuration
    1b26:	80 91 c0 01 	lds	r24, 0x01C0
    1b2a:	90 91 c1 01 	lds	r25, 0x01C1
    1b2e:	89 2b       	or	r24, r25
    1b30:	11 f4       	brne	.+4      	; 0x1b36 <safety_and_idle+0x2e0>
    1b32:	0e 94 af 0b 	call	0x175e	; 0x175e <save_config>
				sei();  //re-enable interrupts
    1b36:	78 94       	sei
    1b38:	5b c0       	rjmp	.+182    	; 0x1bf0 <safety_and_idle+0x39a>
	  
		// if stick is forward - flash out highest rpm this boot
		while (forwardback > (forwardback_center + forwardback_forwardthresh) && throttle < throttle_low)
		{
		   
			set_led_off();
    1b3a:	5d 98       	cbi	0x0b, 5	; 11
			
			//if we haven't recorded an RPM - show a little status flash to show we have signal
			if (max_observed_rpm == 0)
    1b3c:	e1 14       	cp	r14, r1
    1b3e:	f1 04       	cpc	r15, r1
    1b40:	01 05       	cpc	r16, r1
    1b42:	11 05       	cpc	r17, r1
    1b44:	a1 f4       	brne	.+40     	; 0x1b6e <safety_and_idle+0x318>
    1b46:	20 e0       	ldi	r18, 0x00	; 0
    1b48:	30 e0       	ldi	r19, 0x00	; 0
			{
				for (x = 0; x < 15; x++)
				{
					set_led_on();
    1b4a:	5d 9a       	sbi	0x0b, 5	; 11
    1b4c:	88 ea       	ldi	r24, 0xA8	; 168
    1b4e:	91 e6       	ldi	r25, 0x61	; 97
    1b50:	01 97       	sbiw	r24, 0x01	; 1
    1b52:	f1 f7       	brne	.-4      	; 0x1b50 <safety_and_idle+0x2fa>
					_delay_ms (5);
					set_led_off();
    1b54:	5d 98       	cbi	0x0b, 5	; 11
    1b56:	8c e2       	ldi	r24, 0x2C	; 44
    1b58:	91 e0       	ldi	r25, 0x01	; 1
    1b5a:	fe 01       	movw	r30, r28
    1b5c:	31 97       	sbiw	r30, 0x01	; 1
    1b5e:	f1 f7       	brne	.-4      	; 0x1b5c <safety_and_idle+0x306>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1b60:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1b62:	d9 f7       	brne	.-10     	; 0x1b5a <safety_and_idle+0x304>
    1b64:	2f 5f       	subi	r18, 0xFF	; 255
    1b66:	3f 4f       	sbci	r19, 0xFF	; 255
			set_led_off();
			
			//if we haven't recorded an RPM - show a little status flash to show we have signal
			if (max_observed_rpm == 0)
			{
				for (x = 0; x < 15; x++)
    1b68:	2f 30       	cpi	r18, 0x0F	; 15
    1b6a:	31 05       	cpc	r19, r1
    1b6c:	71 f7       	brne	.-36     	; 0x1b4a <safety_and_idle+0x2f4>
    1b6e:	80 e4       	ldi	r24, 0x40	; 64
    1b70:	9f e1       	ldi	r25, 0x1F	; 31
    1b72:	fe 01       	movw	r30, r28
    1b74:	31 97       	sbiw	r30, 0x01	; 1
    1b76:	f1 f7       	brne	.-4      	; 0x1b74 <safety_and_idle+0x31e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1b78:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1b7a:	d9 f7       	brne	.-10     	; 0x1b72 <safety_and_idle+0x31c>
    1b7c:	21 e3       	ldi	r18, 0x31	; 49
    1b7e:	30 e0       	ldi	r19, 0x00	; 0
    1b80:	40 e0       	ldi	r20, 0x00	; 0
    1b82:	50 e0       	ldi	r21, 0x00	; 0
    1b84:	14 c0       	rjmp	.+40     	; 0x1bae <safety_and_idle+0x358>
}



void safety_and_idle(void)
{
    1b86:	2c 59       	subi	r18, 0x9C	; 156
    1b88:	3f 4f       	sbci	r19, 0xFF	; 255
    1b8a:	4f 4f       	sbci	r20, 0xFF	; 255
    1b8c:	5f 4f       	sbci	r21, 0xFF	; 255
			
			x = 49;					//little confusing - but this effectively rounds up (600 rpm = 6 flashes, 650 rpm = 7 flashes)
			while ((x < (max_observed_rpm)) && (forwardback > (forwardback_center + forwardback_forwardthresh)) && throttle < throttle_low)
			{
				x = x + 100;		
				set_led_on();
    1b8e:	5d 9a       	sbi	0x0b, 5	; 11
    1b90:	84 ef       	ldi	r24, 0xF4	; 244
    1b92:	91 e0       	ldi	r25, 0x01	; 1
    1b94:	fe 01       	movw	r30, r28
    1b96:	31 97       	sbiw	r30, 0x01	; 1
    1b98:	f1 f7       	brne	.-4      	; 0x1b96 <safety_and_idle+0x340>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1b9a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1b9c:	d9 f7       	brne	.-10     	; 0x1b94 <safety_and_idle+0x33e>
				_delay_ms (50);
				set_led_off();
    1b9e:	5d 98       	cbi	0x0b, 5	; 11
    1ba0:	80 ea       	ldi	r24, 0xA0	; 160
    1ba2:	9f e0       	ldi	r25, 0x0F	; 15
    1ba4:	fe 01       	movw	r30, r28
    1ba6:	31 97       	sbiw	r30, 0x01	; 1
    1ba8:	f1 f7       	brne	.-4      	; 0x1ba6 <safety_and_idle+0x350>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1baa:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1bac:	d9 f7       	brne	.-10     	; 0x1ba4 <safety_and_idle+0x34e>
			}
			
			_delay_ms (800);
			
			x = 49;					//little confusing - but this effectively rounds up (600 rpm = 6 flashes, 650 rpm = 7 flashes)
			while ((x < (max_observed_rpm)) && (forwardback > (forwardback_center + forwardback_forwardthresh)) && throttle < throttle_low)
    1bae:	2e 15       	cp	r18, r14
    1bb0:	3f 05       	cpc	r19, r15
    1bb2:	40 07       	cpc	r20, r16
    1bb4:	51 07       	cpc	r21, r17
    1bb6:	0c f0       	brlt	.+2      	; 0x1bba <safety_and_idle+0x364>
    1bb8:	43 c0       	rjmp	.+134    	; 0x1c40 <safety_and_idle+0x3ea>
    1bba:	80 91 6c 01 	lds	r24, 0x016C
    1bbe:	90 91 6d 01 	lds	r25, 0x016D
    1bc2:	a0 91 6e 01 	lds	r26, 0x016E
    1bc6:	b0 91 6f 01 	lds	r27, 0x016F
    1bca:	68 16       	cp	r6, r24
    1bcc:	79 06       	cpc	r7, r25
    1bce:	8a 06       	cpc	r8, r26
    1bd0:	9b 06       	cpc	r9, r27
    1bd2:	b4 f5       	brge	.+108    	; 0x1c40 <safety_and_idle+0x3ea>
    1bd4:	80 91 86 01 	lds	r24, 0x0186
    1bd8:	90 91 87 01 	lds	r25, 0x0187
    1bdc:	a0 91 88 01 	lds	r26, 0x0188
    1be0:	b0 91 89 01 	lds	r27, 0x0189
    1be4:	8a 15       	cp	r24, r10
    1be6:	9b 05       	cpc	r25, r11
    1be8:	ac 05       	cpc	r26, r12
    1bea:	bd 05       	cpc	r27, r13
    1bec:	4c f5       	brge	.+82     	; 0x1c40 <safety_and_idle+0x3ea>
    1bee:	cb cf       	rjmp	.-106    	; 0x1b86 <safety_and_idle+0x330>
		}
		      

	  
		// if stick is forward - flash out highest rpm this boot
		while (forwardback > (forwardback_center + forwardback_forwardthresh) && throttle < throttle_low)
    1bf0:	80 91 06 01 	lds	r24, 0x0106
    1bf4:	90 91 07 01 	lds	r25, 0x0107
    1bf8:	20 91 04 01 	lds	r18, 0x0104
    1bfc:	30 91 05 01 	lds	r19, 0x0105
    1c00:	82 0f       	add	r24, r18
    1c02:	93 1f       	adc	r25, r19
    1c04:	3c 01       	movw	r6, r24
    1c06:	88 24       	eor	r8, r8
    1c08:	77 fc       	sbrc	r7, 7
    1c0a:	80 94       	com	r8
    1c0c:	98 2c       	mov	r9, r8
    1c0e:	80 91 00 01 	lds	r24, 0x0100
    1c12:	90 91 01 01 	lds	r25, 0x0101
    1c16:	5c 01       	movw	r10, r24
    1c18:	cc 24       	eor	r12, r12
    1c1a:	b7 fc       	sbrc	r11, 7
    1c1c:	c0 94       	com	r12
    1c1e:	dc 2c       	mov	r13, r12
		{
		   
			set_led_off();
			
			//if we haven't recorded an RPM - show a little status flash to show we have signal
			if (max_observed_rpm == 0)
    1c20:	e0 90 46 01 	lds	r14, 0x0146
    1c24:	f0 90 47 01 	lds	r15, 0x0147
    1c28:	00 91 48 01 	lds	r16, 0x0148
    1c2c:	10 91 49 01 	lds	r17, 0x0149
    1c30:	20 91 64 01 	lds	r18, 0x0164
    1c34:	30 91 65 01 	lds	r19, 0x0165
    1c38:	40 91 66 01 	lds	r20, 0x0166
    1c3c:	50 91 67 01 	lds	r21, 0x0167
		}
		      

	  
		// if stick is forward - flash out highest rpm this boot
		while (forwardback > (forwardback_center + forwardback_forwardthresh) && throttle < throttle_low)
    1c40:	80 91 6c 01 	lds	r24, 0x016C
    1c44:	90 91 6d 01 	lds	r25, 0x016D
    1c48:	a0 91 6e 01 	lds	r26, 0x016E
    1c4c:	b0 91 6f 01 	lds	r27, 0x016F
    1c50:	68 16       	cp	r6, r24
    1c52:	79 06       	cpc	r7, r25
    1c54:	8a 06       	cpc	r8, r26
    1c56:	9b 06       	cpc	r9, r27
    1c58:	74 f4       	brge	.+28     	; 0x1c76 <safety_and_idle+0x420>
    1c5a:	80 91 86 01 	lds	r24, 0x0186
    1c5e:	90 91 87 01 	lds	r25, 0x0187
    1c62:	a0 91 88 01 	lds	r26, 0x0188
    1c66:	b0 91 89 01 	lds	r27, 0x0189
    1c6a:	8a 15       	cp	r24, r10
    1c6c:	9b 05       	cpc	r25, r11
    1c6e:	ac 05       	cpc	r26, r12
    1c70:	bd 05       	cpc	r27, r13
    1c72:	0c f4       	brge	.+2      	; 0x1c76 <safety_and_idle+0x420>
    1c74:	62 cf       	rjmp	.-316    	; 0x1b3a <safety_and_idle+0x2e4>
    1c76:	20 93 64 01 	sts	0x0164, r18
    1c7a:	30 93 65 01 	sts	0x0165, r19
    1c7e:	40 93 66 01 	sts	0x0166, r20
    1c82:	50 93 67 01 	sts	0x0167, r21
	//also - if we've gone more than 11 rotations without getting fresh throttle data - assume something has gone wrong / shutdown
	//since max allowed rotation time is 400ms - should always fail-safe in under 5 seconds
	//in addition - requires 4 good "throttle up" reads in a row before allowing the loop to be left (hopefully prevents stray RC data from causing spin-up)
		

	while (throttle < throttle_low || throttle > (throttle_high + 100) || rotations_since_throttle_was_set > 11 || throttle_up_count < 4)
    1c86:	20 91 86 01 	lds	r18, 0x0186
    1c8a:	30 91 87 01 	lds	r19, 0x0187
    1c8e:	40 91 88 01 	lds	r20, 0x0188
    1c92:	50 91 89 01 	lds	r21, 0x0189
    1c96:	80 91 00 01 	lds	r24, 0x0100
    1c9a:	90 91 01 01 	lds	r25, 0x0101
    1c9e:	7c 01       	movw	r14, r24
    1ca0:	00 27       	eor	r16, r16
    1ca2:	f7 fc       	sbrc	r15, 7
    1ca4:	00 95       	com	r16
    1ca6:	10 2f       	mov	r17, r16
    1ca8:	2e 15       	cp	r18, r14
    1caa:	3f 05       	cpc	r19, r15
    1cac:	40 07       	cpc	r20, r16
    1cae:	51 07       	cpc	r21, r17
    1cb0:	0c f4       	brge	.+2      	; 0x1cb4 <safety_and_idle+0x45e>
    1cb2:	ee cd       	rjmp	.-1060   	; 0x1890 <safety_and_idle+0x3a>
    1cb4:	20 91 86 01 	lds	r18, 0x0186
    1cb8:	30 91 87 01 	lds	r19, 0x0187
    1cbc:	40 91 88 01 	lds	r20, 0x0188
    1cc0:	50 91 89 01 	lds	r21, 0x0189
    1cc4:	80 91 02 01 	lds	r24, 0x0102
    1cc8:	90 91 03 01 	lds	r25, 0x0103
    1ccc:	8c 59       	subi	r24, 0x9C	; 156
    1cce:	9f 4f       	sbci	r25, 0xFF	; 255
    1cd0:	aa 27       	eor	r26, r26
    1cd2:	97 fd       	sbrc	r25, 7
    1cd4:	a0 95       	com	r26
    1cd6:	ba 2f       	mov	r27, r26
    1cd8:	82 17       	cp	r24, r18
    1cda:	93 07       	cpc	r25, r19
    1cdc:	a4 07       	cpc	r26, r20
    1cde:	b5 07       	cpc	r27, r21
    1ce0:	0c f4       	brge	.+2      	; 0x1ce4 <safety_and_idle+0x48e>
    1ce2:	d6 cd       	rjmp	.-1108   	; 0x1890 <safety_and_idle+0x3a>
    1ce4:	80 91 42 01 	lds	r24, 0x0142
    1ce8:	90 91 43 01 	lds	r25, 0x0143
    1cec:	0c 97       	sbiw	r24, 0x0c	; 12
    1cee:	0c f0       	brlt	.+2      	; 0x1cf2 <safety_and_idle+0x49c>
    1cf0:	cf cd       	rjmp	.-1122   	; 0x1890 <safety_and_idle+0x3a>
    1cf2:	80 91 44 01 	lds	r24, 0x0144
    1cf6:	90 91 45 01 	lds	r25, 0x0145
    1cfa:	04 97       	sbiw	r24, 0x04	; 4
    1cfc:	0c f4       	brge	.+2      	; 0x1d00 <safety_and_idle+0x4aa>
    1cfe:	c8 cd       	rjmp	.-1136   	; 0x1890 <safety_and_idle+0x3a>
		}


	}

}
    1d00:	df 91       	pop	r29
    1d02:	cf 91       	pop	r28
    1d04:	1f 91       	pop	r17
    1d06:	0f 91       	pop	r16
    1d08:	ff 90       	pop	r15
    1d0a:	ef 90       	pop	r14
    1d0c:	df 90       	pop	r13
    1d0e:	cf 90       	pop	r12
    1d10:	bf 90       	pop	r11
    1d12:	af 90       	pop	r10
    1d14:	9f 90       	pop	r9
    1d16:	8f 90       	pop	r8
    1d18:	7f 90       	pop	r7
    1d1a:	6f 90       	pop	r6
    1d1c:	5f 90       	pop	r5
    1d1e:	4f 90       	pop	r4
    1d20:	3f 90       	pop	r3
    1d22:	2f 90       	pop	r2
    1d24:	08 95       	ret

00001d26 <load_config>:

void load_config(void)
{
    1d26:	af 92       	push	r10
    1d28:	bf 92       	push	r11
    1d2a:	cf 92       	push	r12
    1d2c:	df 92       	push	r13
    1d2e:	ef 92       	push	r14
    1d30:	ff 92       	push	r15
    1d32:	0f 93       	push	r16
    1d34:	1f 93       	push	r17
    Read one 16-bit word (little endian) from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint16_t eeprom_read_word (const uint16_t *__p)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    return __eerd_word (__p, eeprom_read_byte);
    1d36:	80 e0       	ldi	r24, 0x00	; 0
    1d38:	90 e0       	ldi	r25, 0x00	; 0
    1d3a:	63 e5       	ldi	r22, 0x53	; 83
    1d3c:	70 e0       	ldi	r23, 0x00	; 0
    1d3e:	0e 94 6f 0f 	call	0x1ede	; 0x1ede <__eerd_word>

	float tracking_word1;		//first word of tracking_comp
	float tracking_word2;		//second word of tracking_comp

	//only load config data if "saved_data_valid" indicates it was saved previously
	if (eeprom_read_word(&saved_data_valid) == 128)
    1d42:	80 38       	cpi	r24, 0x80	; 128
    1d44:	91 05       	cpc	r25, r1
    1d46:	09 f0       	breq	.+2      	; 0x1d4a <load_config+0x24>
    1d48:	6e c0       	rjmp	.+220    	; 0x1e26 <load_config+0x100>
    1d4a:	82 e0       	ldi	r24, 0x02	; 2
    1d4c:	90 e0       	ldi	r25, 0x00	; 0
    1d4e:	63 e5       	ldi	r22, 0x53	; 83
    1d50:	70 e0       	ldi	r23, 0x00	; 0
    1d52:	0e 94 6f 0f 	call	0x1ede	; 0x1ede <__eerd_word>
	{

		led_adjust = eeprom_read_word(&led_adjust_save);	//loads led offset
    1d56:	a0 e0       	ldi	r26, 0x00	; 0
    1d58:	b0 e0       	ldi	r27, 0x00	; 0
    1d5a:	bc 01       	movw	r22, r24
    1d5c:	cd 01       	movw	r24, r26
    1d5e:	0e 94 9c 10 	call	0x2138	; 0x2138 <__floatunsisf>
    1d62:	60 93 30 01 	sts	0x0130, r22
    1d66:	70 93 31 01 	sts	0x0131, r23
    1d6a:	80 93 32 01 	sts	0x0132, r24
    1d6e:	90 93 33 01 	sts	0x0133, r25
    1d72:	84 e0       	ldi	r24, 0x04	; 4
    1d74:	90 e0       	ldi	r25, 0x00	; 0
    1d76:	63 e5       	ldi	r22, 0x53	; 83
    1d78:	70 e0       	ldi	r23, 0x00	; 0
    1d7a:	0e 94 6f 0f 	call	0x1ede	; 0x1ede <__eerd_word>
		tracking_word1 = (eeprom_read_word(&tracking_comp_save_word1));		//loads tracking comp
    1d7e:	a0 e0       	ldi	r26, 0x00	; 0
    1d80:	b0 e0       	ldi	r27, 0x00	; 0
    1d82:	bc 01       	movw	r22, r24
    1d84:	cd 01       	movw	r24, r26
    1d86:	0e 94 9c 10 	call	0x2138	; 0x2138 <__floatunsisf>
    1d8a:	5b 01       	movw	r10, r22
    1d8c:	6c 01       	movw	r12, r24
    1d8e:	86 e0       	ldi	r24, 0x06	; 6
    1d90:	90 e0       	ldi	r25, 0x00	; 0
    1d92:	63 e5       	ldi	r22, 0x53	; 83
    1d94:	70 e0       	ldi	r23, 0x00	; 0
    1d96:	0e 94 6f 0f 	call	0x1ede	; 0x1ede <__eerd_word>
		tracking_word2 = (eeprom_read_word(&tracking_comp_save_word2));		//loads tracking comp
    1d9a:	a0 e0       	ldi	r26, 0x00	; 0
    1d9c:	b0 e0       	ldi	r27, 0x00	; 0
    1d9e:	bc 01       	movw	r22, r24
    1da0:	cd 01       	movw	r24, r26
    1da2:	0e 94 9c 10 	call	0x2138	; 0x2138 <__floatunsisf>
    1da6:	7b 01       	movw	r14, r22
    1da8:	8c 01       	movw	r16, r24
    1daa:	88 e0       	ldi	r24, 0x08	; 8
    1dac:	90 e0       	ldi	r25, 0x00	; 0
    1dae:	63 e5       	ldi	r22, 0x53	; 83
    1db0:	70 e0       	ldi	r23, 0x00	; 0
    1db2:	0e 94 6f 0f 	call	0x1ede	; 0x1ede <__eerd_word>
		heading_center = eeprom_read_word(&heading_center_save);	//loads heading_center
    1db6:	90 93 0b 01 	sts	0x010B, r25
    1dba:	80 93 0a 01 	sts	0x010A, r24
    1dbe:	8a e0       	ldi	r24, 0x0A	; 10
    1dc0:	90 e0       	ldi	r25, 0x00	; 0
    1dc2:	63 e5       	ldi	r22, 0x53	; 83
    1dc4:	70 e0       	ldi	r23, 0x00	; 0
    1dc6:	0e 94 6f 0f 	call	0x1ede	; 0x1ede <__eerd_word>
		base_accel = eeprom_read_word(&base_accel_save);		//loads base accelerometer value
    1dca:	90 93 35 01 	sts	0x0135, r25
    1dce:	80 93 34 01 	sts	0x0134, r24
	
		tracking_word1 = tracking_word1 / 1000;	//converts 1st tracking comp word back to float
		
		tracking_word2 = tracking_word2 / 1000;		//converts 2nd tracking comp word back to float
    1dd2:	c8 01       	movw	r24, r16
    1dd4:	b7 01       	movw	r22, r14
    1dd6:	20 e0       	ldi	r18, 0x00	; 0
    1dd8:	30 e0       	ldi	r19, 0x00	; 0
    1dda:	4a e7       	ldi	r20, 0x7A	; 122
    1ddc:	54 e4       	ldi	r21, 0x44	; 68
    1dde:	0e 94 03 10 	call	0x2006	; 0x2006 <__divsf3>
    1de2:	7b 01       	movw	r14, r22
    1de4:	8c 01       	movw	r16, r24
		tracking_word2 = tracking_word2 / 10000;	//put it in the correct decimal place
		
		tracking_comp = tracking_word1 + tracking_word2;	//puts the two floats together
    1de6:	c6 01       	movw	r24, r12
    1de8:	b5 01       	movw	r22, r10
    1dea:	20 e0       	ldi	r18, 0x00	; 0
    1dec:	30 e0       	ldi	r19, 0x00	; 0
    1dee:	4a e7       	ldi	r20, 0x7A	; 122
    1df0:	54 e4       	ldi	r21, 0x44	; 68
    1df2:	0e 94 03 10 	call	0x2006	; 0x2006 <__divsf3>
    1df6:	5b 01       	movw	r10, r22
    1df8:	6c 01       	movw	r12, r24
    1dfa:	c8 01       	movw	r24, r16
    1dfc:	b7 01       	movw	r22, r14
    1dfe:	20 e0       	ldi	r18, 0x00	; 0
    1e00:	30 e4       	ldi	r19, 0x40	; 64
    1e02:	4c e1       	ldi	r20, 0x1C	; 28
    1e04:	56 e4       	ldi	r21, 0x46	; 70
    1e06:	0e 94 03 10 	call	0x2006	; 0x2006 <__divsf3>
    1e0a:	9b 01       	movw	r18, r22
    1e0c:	ac 01       	movw	r20, r24
    1e0e:	c6 01       	movw	r24, r12
    1e10:	b5 01       	movw	r22, r10
    1e12:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <__addsf3>
    1e16:	60 93 2c 01 	sts	0x012C, r22
    1e1a:	70 93 2d 01 	sts	0x012D, r23
    1e1e:	80 93 2e 01 	sts	0x012E, r24
    1e22:	90 93 2f 01 	sts	0x012F, r25
	}

}
    1e26:	1f 91       	pop	r17
    1e28:	0f 91       	pop	r16
    1e2a:	ff 90       	pop	r15
    1e2c:	ef 90       	pop	r14
    1e2e:	df 90       	pop	r13
    1e30:	cf 90       	pop	r12
    1e32:	bf 90       	pop	r11
    1e34:	af 90       	pop	r10
    1e36:	08 95       	ret

00001e38 <main>:

int main(void)
{
	
		
	setup();			//do initial setup stuff - set pins / interrupts / etc.
    1e38:	0e 94 6d 02 	call	0x4da	; 0x4da <setup>
			
	load_config();		//try to load configuration data from ROM
    1e3c:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <load_config>
	{		
		
												//the lines before main_calculations don't have their execution time accounted for in the code 
												//but only take approximately 2us to execute (measured) - (0.006% of a rotation at 2000 rpm)
												
		rotations_since_throttle_was_set ++;	//used as a safety counter - if no good throttle data is received for certain number of rotations - the bot shuts down
    1e40:	80 91 42 01 	lds	r24, 0x0142
    1e44:	90 91 43 01 	lds	r25, 0x0143
    1e48:	01 96       	adiw	r24, 0x01	; 1
    1e4a:	90 93 43 01 	sts	0x0143, r25
    1e4e:	80 93 42 01 	sts	0x0142, r24
		rotation_count ++;
    1e52:	80 91 3a 01 	lds	r24, 0x013A
    1e56:	90 91 3b 01 	lds	r25, 0x013B
    1e5a:	a0 91 3c 01 	lds	r26, 0x013C
    1e5e:	b0 91 3d 01 	lds	r27, 0x013D
    1e62:	01 96       	adiw	r24, 0x01	; 1
    1e64:	a1 1d       	adc	r26, r1
    1e66:	b1 1d       	adc	r27, r1
    1e68:	80 93 3a 01 	sts	0x013A, r24
    1e6c:	90 93 3b 01 	sts	0x013B, r25
    1e70:	a0 93 3c 01 	sts	0x013C, r26
    1e74:	b0 93 3d 01 	sts	0x013D, r27
				
		safety_and_idle();						//does safety check / sees if we're just sitting idle - also checks if config mode is requested
    1e78:	0e 94 2b 0c 	call	0x1856	; 0x1856 <safety_and_idle>
		
		alternate_motor_cycle = !alternate_motor_cycle;     //alternates alternate_motor_cycle - used to balance spin / avoid favoring one motor
    1e7c:	20 e0       	ldi	r18, 0x00	; 0
    1e7e:	30 e0       	ldi	r19, 0x00	; 0
    1e80:	80 91 3e 01 	lds	r24, 0x013E
    1e84:	90 91 3f 01 	lds	r25, 0x013F
    1e88:	89 2b       	or	r24, r25
    1e8a:	11 f4       	brne	.+4      	; 0x1e90 <main+0x58>
    1e8c:	21 e0       	ldi	r18, 0x01	; 1
    1e8e:	30 e0       	ldi	r19, 0x00	; 0
    1e90:	30 93 3f 01 	sts	0x013F, r19
    1e94:	20 93 3e 01 	sts	0x013E, r18

		led_hold_over = 0;						//reset the LED counter
    1e98:	10 92 68 01 	sts	0x0168, r1
    1e9c:	10 92 69 01 	sts	0x0169, r1
    1ea0:	10 92 6a 01 	sts	0x016A, r1
    1ea4:	10 92 6b 01 	sts	0x016B, r1
		
		main_calculations();					//reads accel data and does all the math
    1ea8:	0e 94 84 06 	call	0xd08	; 0xd08 <main_calculations>
												//takes about 400us - but is measured real-time / compensated for

		do_spin_180(1);							//1st 180 degrees of spin
    1eac:	81 e0       	ldi	r24, 0x01	; 1
    1eae:	90 e0       	ldi	r25, 0x00	; 0
    1eb0:	0e 94 cf 02 	call	0x59e	; 0x59e <do_spin_180>

		led_hold_over = TCNT1;					//carry over led_counter from last spin
    1eb4:	80 91 84 00 	lds	r24, 0x0084
    1eb8:	90 91 85 00 	lds	r25, 0x0085
    1ebc:	a0 e0       	ldi	r26, 0x00	; 0
    1ebe:	b0 e0       	ldi	r27, 0x00	; 0
    1ec0:	80 93 68 01 	sts	0x0168, r24
    1ec4:	90 93 69 01 	sts	0x0169, r25
    1ec8:	a0 93 6a 01 	sts	0x016A, r26
    1ecc:	b0 93 6b 01 	sts	0x016B, r27
				
		main_calculations();					//read accel / do the main calculations again
    1ed0:	0e 94 84 06 	call	0xd08	; 0xd08 <main_calculations>
												//time doing math is tracked - but since time doing calculations is outside the motor loop - if it all falls in one cycle or the other...
												//..it may still be enough to cause a slight bias when translating
												//should really present a very small amount of time (less than 1% at 2000rpm) 
												//since we're resampling the accel - this may also provide a little better accuracy

		do_spin_180(2);							//2nd 180 degrees of spin
    1ed4:	82 e0       	ldi	r24, 0x02	; 2
    1ed6:	90 e0       	ldi	r25, 0x00	; 0
    1ed8:	0e 94 cf 02 	call	0x59e	; 0x59e <do_spin_180>
    1edc:	b1 cf       	rjmp	.-158    	; 0x1e40 <main+0x8>

00001ede <__eerd_word>:
    1ede:	df 92       	push	r13
    1ee0:	ef 92       	push	r14
    1ee2:	ff 92       	push	r15
    1ee4:	0f 93       	push	r16
    1ee6:	1f 93       	push	r17
    1ee8:	7b 01       	movw	r14, r22
    1eea:	8c 01       	movw	r16, r24
    1eec:	fb 01       	movw	r30, r22
    1eee:	09 95       	icall
    1ef0:	d8 2e       	mov	r13, r24
    1ef2:	c8 01       	movw	r24, r16
    1ef4:	01 96       	adiw	r24, 0x01	; 1
    1ef6:	f7 01       	movw	r30, r14
    1ef8:	09 95       	icall
    1efa:	98 2f       	mov	r25, r24
    1efc:	8d 2d       	mov	r24, r13
    1efe:	1f 91       	pop	r17
    1f00:	0f 91       	pop	r16
    1f02:	ff 90       	pop	r15
    1f04:	ef 90       	pop	r14
    1f06:	df 90       	pop	r13
    1f08:	08 95       	ret

00001f0a <__eewr_word>:
    1f0a:	df 92       	push	r13
    1f0c:	ef 92       	push	r14
    1f0e:	ff 92       	push	r15
    1f10:	0f 93       	push	r16
    1f12:	1f 93       	push	r17
    1f14:	d7 2e       	mov	r13, r23
    1f16:	7a 01       	movw	r14, r20
    1f18:	8c 01       	movw	r16, r24
    1f1a:	fa 01       	movw	r30, r20
    1f1c:	09 95       	icall
    1f1e:	c8 01       	movw	r24, r16
    1f20:	01 96       	adiw	r24, 0x01	; 1
    1f22:	6d 2d       	mov	r22, r13
    1f24:	f7 01       	movw	r30, r14
    1f26:	09 95       	icall
    1f28:	1f 91       	pop	r17
    1f2a:	0f 91       	pop	r16
    1f2c:	ff 90       	pop	r15
    1f2e:	ef 90       	pop	r14
    1f30:	df 90       	pop	r13
    1f32:	08 95       	ret

00001f34 <__subsf3>:
    1f34:	50 58       	subi	r21, 0x80	; 128

00001f36 <__addsf3>:
    1f36:	bb 27       	eor	r27, r27
    1f38:	aa 27       	eor	r26, r26
    1f3a:	0e d0       	rcall	.+28     	; 0x1f58 <__addsf3x>
    1f3c:	75 c1       	rjmp	.+746    	; 0x2228 <__fp_round>
    1f3e:	66 d1       	rcall	.+716    	; 0x220c <__fp_pscA>
    1f40:	30 f0       	brcs	.+12     	; 0x1f4e <__addsf3+0x18>
    1f42:	6b d1       	rcall	.+726    	; 0x221a <__fp_pscB>
    1f44:	20 f0       	brcs	.+8      	; 0x1f4e <__addsf3+0x18>
    1f46:	31 f4       	brne	.+12     	; 0x1f54 <__addsf3+0x1e>
    1f48:	9f 3f       	cpi	r25, 0xFF	; 255
    1f4a:	11 f4       	brne	.+4      	; 0x1f50 <__addsf3+0x1a>
    1f4c:	1e f4       	brtc	.+6      	; 0x1f54 <__addsf3+0x1e>
    1f4e:	5b c1       	rjmp	.+694    	; 0x2206 <__fp_nan>
    1f50:	0e f4       	brtc	.+2      	; 0x1f54 <__addsf3+0x1e>
    1f52:	e0 95       	com	r30
    1f54:	e7 fb       	bst	r30, 7
    1f56:	51 c1       	rjmp	.+674    	; 0x21fa <__fp_inf>

00001f58 <__addsf3x>:
    1f58:	e9 2f       	mov	r30, r25
    1f5a:	77 d1       	rcall	.+750    	; 0x224a <__fp_split3>
    1f5c:	80 f3       	brcs	.-32     	; 0x1f3e <__addsf3+0x8>
    1f5e:	ba 17       	cp	r27, r26
    1f60:	62 07       	cpc	r22, r18
    1f62:	73 07       	cpc	r23, r19
    1f64:	84 07       	cpc	r24, r20
    1f66:	95 07       	cpc	r25, r21
    1f68:	18 f0       	brcs	.+6      	; 0x1f70 <__addsf3x+0x18>
    1f6a:	71 f4       	brne	.+28     	; 0x1f88 <__addsf3x+0x30>
    1f6c:	9e f5       	brtc	.+102    	; 0x1fd4 <__addsf3x+0x7c>
    1f6e:	8f c1       	rjmp	.+798    	; 0x228e <__fp_zero>
    1f70:	0e f4       	brtc	.+2      	; 0x1f74 <__addsf3x+0x1c>
    1f72:	e0 95       	com	r30
    1f74:	0b 2e       	mov	r0, r27
    1f76:	ba 2f       	mov	r27, r26
    1f78:	a0 2d       	mov	r26, r0
    1f7a:	0b 01       	movw	r0, r22
    1f7c:	b9 01       	movw	r22, r18
    1f7e:	90 01       	movw	r18, r0
    1f80:	0c 01       	movw	r0, r24
    1f82:	ca 01       	movw	r24, r20
    1f84:	a0 01       	movw	r20, r0
    1f86:	11 24       	eor	r1, r1
    1f88:	ff 27       	eor	r31, r31
    1f8a:	59 1b       	sub	r21, r25
    1f8c:	99 f0       	breq	.+38     	; 0x1fb4 <__addsf3x+0x5c>
    1f8e:	59 3f       	cpi	r21, 0xF9	; 249
    1f90:	50 f4       	brcc	.+20     	; 0x1fa6 <__addsf3x+0x4e>
    1f92:	50 3e       	cpi	r21, 0xE0	; 224
    1f94:	68 f1       	brcs	.+90     	; 0x1ff0 <__addsf3x+0x98>
    1f96:	1a 16       	cp	r1, r26
    1f98:	f0 40       	sbci	r31, 0x00	; 0
    1f9a:	a2 2f       	mov	r26, r18
    1f9c:	23 2f       	mov	r18, r19
    1f9e:	34 2f       	mov	r19, r20
    1fa0:	44 27       	eor	r20, r20
    1fa2:	58 5f       	subi	r21, 0xF8	; 248
    1fa4:	f3 cf       	rjmp	.-26     	; 0x1f8c <__addsf3x+0x34>
    1fa6:	46 95       	lsr	r20
    1fa8:	37 95       	ror	r19
    1faa:	27 95       	ror	r18
    1fac:	a7 95       	ror	r26
    1fae:	f0 40       	sbci	r31, 0x00	; 0
    1fb0:	53 95       	inc	r21
    1fb2:	c9 f7       	brne	.-14     	; 0x1fa6 <__addsf3x+0x4e>
    1fb4:	7e f4       	brtc	.+30     	; 0x1fd4 <__addsf3x+0x7c>
    1fb6:	1f 16       	cp	r1, r31
    1fb8:	ba 0b       	sbc	r27, r26
    1fba:	62 0b       	sbc	r22, r18
    1fbc:	73 0b       	sbc	r23, r19
    1fbe:	84 0b       	sbc	r24, r20
    1fc0:	ba f0       	brmi	.+46     	; 0x1ff0 <__addsf3x+0x98>
    1fc2:	91 50       	subi	r25, 0x01	; 1
    1fc4:	a1 f0       	breq	.+40     	; 0x1fee <__addsf3x+0x96>
    1fc6:	ff 0f       	add	r31, r31
    1fc8:	bb 1f       	adc	r27, r27
    1fca:	66 1f       	adc	r22, r22
    1fcc:	77 1f       	adc	r23, r23
    1fce:	88 1f       	adc	r24, r24
    1fd0:	c2 f7       	brpl	.-16     	; 0x1fc2 <__addsf3x+0x6a>
    1fd2:	0e c0       	rjmp	.+28     	; 0x1ff0 <__addsf3x+0x98>
    1fd4:	ba 0f       	add	r27, r26
    1fd6:	62 1f       	adc	r22, r18
    1fd8:	73 1f       	adc	r23, r19
    1fda:	84 1f       	adc	r24, r20
    1fdc:	48 f4       	brcc	.+18     	; 0x1ff0 <__addsf3x+0x98>
    1fde:	87 95       	ror	r24
    1fe0:	77 95       	ror	r23
    1fe2:	67 95       	ror	r22
    1fe4:	b7 95       	ror	r27
    1fe6:	f7 95       	ror	r31
    1fe8:	9e 3f       	cpi	r25, 0xFE	; 254
    1fea:	08 f0       	brcs	.+2      	; 0x1fee <__addsf3x+0x96>
    1fec:	b3 cf       	rjmp	.-154    	; 0x1f54 <__addsf3+0x1e>
    1fee:	93 95       	inc	r25
    1ff0:	88 0f       	add	r24, r24
    1ff2:	08 f0       	brcs	.+2      	; 0x1ff6 <__addsf3x+0x9e>
    1ff4:	99 27       	eor	r25, r25
    1ff6:	ee 0f       	add	r30, r30
    1ff8:	97 95       	ror	r25
    1ffa:	87 95       	ror	r24
    1ffc:	08 95       	ret

00001ffe <__cmpsf2>:
    1ffe:	d9 d0       	rcall	.+434    	; 0x21b2 <__fp_cmp>
    2000:	08 f4       	brcc	.+2      	; 0x2004 <__cmpsf2+0x6>
    2002:	81 e0       	ldi	r24, 0x01	; 1
    2004:	08 95       	ret

00002006 <__divsf3>:
    2006:	0c d0       	rcall	.+24     	; 0x2020 <__divsf3x>
    2008:	0f c1       	rjmp	.+542    	; 0x2228 <__fp_round>
    200a:	07 d1       	rcall	.+526    	; 0x221a <__fp_pscB>
    200c:	40 f0       	brcs	.+16     	; 0x201e <__divsf3+0x18>
    200e:	fe d0       	rcall	.+508    	; 0x220c <__fp_pscA>
    2010:	30 f0       	brcs	.+12     	; 0x201e <__divsf3+0x18>
    2012:	21 f4       	brne	.+8      	; 0x201c <__divsf3+0x16>
    2014:	5f 3f       	cpi	r21, 0xFF	; 255
    2016:	19 f0       	breq	.+6      	; 0x201e <__divsf3+0x18>
    2018:	f0 c0       	rjmp	.+480    	; 0x21fa <__fp_inf>
    201a:	51 11       	cpse	r21, r1
    201c:	39 c1       	rjmp	.+626    	; 0x2290 <__fp_szero>
    201e:	f3 c0       	rjmp	.+486    	; 0x2206 <__fp_nan>

00002020 <__divsf3x>:
    2020:	14 d1       	rcall	.+552    	; 0x224a <__fp_split3>
    2022:	98 f3       	brcs	.-26     	; 0x200a <__divsf3+0x4>

00002024 <__divsf3_pse>:
    2024:	99 23       	and	r25, r25
    2026:	c9 f3       	breq	.-14     	; 0x201a <__divsf3+0x14>
    2028:	55 23       	and	r21, r21
    202a:	b1 f3       	breq	.-20     	; 0x2018 <__divsf3+0x12>
    202c:	95 1b       	sub	r25, r21
    202e:	55 0b       	sbc	r21, r21
    2030:	bb 27       	eor	r27, r27
    2032:	aa 27       	eor	r26, r26
    2034:	62 17       	cp	r22, r18
    2036:	73 07       	cpc	r23, r19
    2038:	84 07       	cpc	r24, r20
    203a:	38 f0       	brcs	.+14     	; 0x204a <__divsf3_pse+0x26>
    203c:	9f 5f       	subi	r25, 0xFF	; 255
    203e:	5f 4f       	sbci	r21, 0xFF	; 255
    2040:	22 0f       	add	r18, r18
    2042:	33 1f       	adc	r19, r19
    2044:	44 1f       	adc	r20, r20
    2046:	aa 1f       	adc	r26, r26
    2048:	a9 f3       	breq	.-22     	; 0x2034 <__divsf3_pse+0x10>
    204a:	33 d0       	rcall	.+102    	; 0x20b2 <__divsf3_pse+0x8e>
    204c:	0e 2e       	mov	r0, r30
    204e:	3a f0       	brmi	.+14     	; 0x205e <__divsf3_pse+0x3a>
    2050:	e0 e8       	ldi	r30, 0x80	; 128
    2052:	30 d0       	rcall	.+96     	; 0x20b4 <__divsf3_pse+0x90>
    2054:	91 50       	subi	r25, 0x01	; 1
    2056:	50 40       	sbci	r21, 0x00	; 0
    2058:	e6 95       	lsr	r30
    205a:	00 1c       	adc	r0, r0
    205c:	ca f7       	brpl	.-14     	; 0x2050 <__divsf3_pse+0x2c>
    205e:	29 d0       	rcall	.+82     	; 0x20b2 <__divsf3_pse+0x8e>
    2060:	fe 2f       	mov	r31, r30
    2062:	27 d0       	rcall	.+78     	; 0x20b2 <__divsf3_pse+0x8e>
    2064:	66 0f       	add	r22, r22
    2066:	77 1f       	adc	r23, r23
    2068:	88 1f       	adc	r24, r24
    206a:	bb 1f       	adc	r27, r27
    206c:	26 17       	cp	r18, r22
    206e:	37 07       	cpc	r19, r23
    2070:	48 07       	cpc	r20, r24
    2072:	ab 07       	cpc	r26, r27
    2074:	b0 e8       	ldi	r27, 0x80	; 128
    2076:	09 f0       	breq	.+2      	; 0x207a <__divsf3_pse+0x56>
    2078:	bb 0b       	sbc	r27, r27
    207a:	80 2d       	mov	r24, r0
    207c:	bf 01       	movw	r22, r30
    207e:	ff 27       	eor	r31, r31
    2080:	93 58       	subi	r25, 0x83	; 131
    2082:	5f 4f       	sbci	r21, 0xFF	; 255
    2084:	2a f0       	brmi	.+10     	; 0x2090 <__divsf3_pse+0x6c>
    2086:	9e 3f       	cpi	r25, 0xFE	; 254
    2088:	51 05       	cpc	r21, r1
    208a:	68 f0       	brcs	.+26     	; 0x20a6 <__divsf3_pse+0x82>
    208c:	b6 c0       	rjmp	.+364    	; 0x21fa <__fp_inf>
    208e:	00 c1       	rjmp	.+512    	; 0x2290 <__fp_szero>
    2090:	5f 3f       	cpi	r21, 0xFF	; 255
    2092:	ec f3       	brlt	.-6      	; 0x208e <__divsf3_pse+0x6a>
    2094:	98 3e       	cpi	r25, 0xE8	; 232
    2096:	dc f3       	brlt	.-10     	; 0x208e <__divsf3_pse+0x6a>
    2098:	86 95       	lsr	r24
    209a:	77 95       	ror	r23
    209c:	67 95       	ror	r22
    209e:	b7 95       	ror	r27
    20a0:	f7 95       	ror	r31
    20a2:	9f 5f       	subi	r25, 0xFF	; 255
    20a4:	c9 f7       	brne	.-14     	; 0x2098 <__divsf3_pse+0x74>
    20a6:	88 0f       	add	r24, r24
    20a8:	91 1d       	adc	r25, r1
    20aa:	96 95       	lsr	r25
    20ac:	87 95       	ror	r24
    20ae:	97 f9       	bld	r25, 7
    20b0:	08 95       	ret
    20b2:	e1 e0       	ldi	r30, 0x01	; 1
    20b4:	66 0f       	add	r22, r22
    20b6:	77 1f       	adc	r23, r23
    20b8:	88 1f       	adc	r24, r24
    20ba:	bb 1f       	adc	r27, r27
    20bc:	62 17       	cp	r22, r18
    20be:	73 07       	cpc	r23, r19
    20c0:	84 07       	cpc	r24, r20
    20c2:	ba 07       	cpc	r27, r26
    20c4:	20 f0       	brcs	.+8      	; 0x20ce <__divsf3_pse+0xaa>
    20c6:	62 1b       	sub	r22, r18
    20c8:	73 0b       	sbc	r23, r19
    20ca:	84 0b       	sbc	r24, r20
    20cc:	ba 0b       	sbc	r27, r26
    20ce:	ee 1f       	adc	r30, r30
    20d0:	88 f7       	brcc	.-30     	; 0x20b4 <__divsf3_pse+0x90>
    20d2:	e0 95       	com	r30
    20d4:	08 95       	ret

000020d6 <__fixsfsi>:
    20d6:	04 d0       	rcall	.+8      	; 0x20e0 <__fixunssfsi>
    20d8:	68 94       	set
    20da:	b1 11       	cpse	r27, r1
    20dc:	d9 c0       	rjmp	.+434    	; 0x2290 <__fp_szero>
    20de:	08 95       	ret

000020e0 <__fixunssfsi>:
    20e0:	bc d0       	rcall	.+376    	; 0x225a <__fp_splitA>
    20e2:	88 f0       	brcs	.+34     	; 0x2106 <__fixunssfsi+0x26>
    20e4:	9f 57       	subi	r25, 0x7F	; 127
    20e6:	90 f0       	brcs	.+36     	; 0x210c <__fixunssfsi+0x2c>
    20e8:	b9 2f       	mov	r27, r25
    20ea:	99 27       	eor	r25, r25
    20ec:	b7 51       	subi	r27, 0x17	; 23
    20ee:	a0 f0       	brcs	.+40     	; 0x2118 <__fixunssfsi+0x38>
    20f0:	d1 f0       	breq	.+52     	; 0x2126 <__fixunssfsi+0x46>
    20f2:	66 0f       	add	r22, r22
    20f4:	77 1f       	adc	r23, r23
    20f6:	88 1f       	adc	r24, r24
    20f8:	99 1f       	adc	r25, r25
    20fa:	1a f0       	brmi	.+6      	; 0x2102 <__fixunssfsi+0x22>
    20fc:	ba 95       	dec	r27
    20fe:	c9 f7       	brne	.-14     	; 0x20f2 <__fixunssfsi+0x12>
    2100:	12 c0       	rjmp	.+36     	; 0x2126 <__fixunssfsi+0x46>
    2102:	b1 30       	cpi	r27, 0x01	; 1
    2104:	81 f0       	breq	.+32     	; 0x2126 <__fixunssfsi+0x46>
    2106:	c3 d0       	rcall	.+390    	; 0x228e <__fp_zero>
    2108:	b1 e0       	ldi	r27, 0x01	; 1
    210a:	08 95       	ret
    210c:	c0 c0       	rjmp	.+384    	; 0x228e <__fp_zero>
    210e:	67 2f       	mov	r22, r23
    2110:	78 2f       	mov	r23, r24
    2112:	88 27       	eor	r24, r24
    2114:	b8 5f       	subi	r27, 0xF8	; 248
    2116:	39 f0       	breq	.+14     	; 0x2126 <__fixunssfsi+0x46>
    2118:	b9 3f       	cpi	r27, 0xF9	; 249
    211a:	cc f3       	brlt	.-14     	; 0x210e <__fixunssfsi+0x2e>
    211c:	86 95       	lsr	r24
    211e:	77 95       	ror	r23
    2120:	67 95       	ror	r22
    2122:	b3 95       	inc	r27
    2124:	d9 f7       	brne	.-10     	; 0x211c <__fixunssfsi+0x3c>
    2126:	3e f4       	brtc	.+14     	; 0x2136 <__fixunssfsi+0x56>
    2128:	90 95       	com	r25
    212a:	80 95       	com	r24
    212c:	70 95       	com	r23
    212e:	61 95       	neg	r22
    2130:	7f 4f       	sbci	r23, 0xFF	; 255
    2132:	8f 4f       	sbci	r24, 0xFF	; 255
    2134:	9f 4f       	sbci	r25, 0xFF	; 255
    2136:	08 95       	ret

00002138 <__floatunsisf>:
    2138:	e8 94       	clt
    213a:	09 c0       	rjmp	.+18     	; 0x214e <__floatsisf+0x12>

0000213c <__floatsisf>:
    213c:	97 fb       	bst	r25, 7
    213e:	3e f4       	brtc	.+14     	; 0x214e <__floatsisf+0x12>
    2140:	90 95       	com	r25
    2142:	80 95       	com	r24
    2144:	70 95       	com	r23
    2146:	61 95       	neg	r22
    2148:	7f 4f       	sbci	r23, 0xFF	; 255
    214a:	8f 4f       	sbci	r24, 0xFF	; 255
    214c:	9f 4f       	sbci	r25, 0xFF	; 255
    214e:	99 23       	and	r25, r25
    2150:	a9 f0       	breq	.+42     	; 0x217c <__floatsisf+0x40>
    2152:	f9 2f       	mov	r31, r25
    2154:	96 e9       	ldi	r25, 0x96	; 150
    2156:	bb 27       	eor	r27, r27
    2158:	93 95       	inc	r25
    215a:	f6 95       	lsr	r31
    215c:	87 95       	ror	r24
    215e:	77 95       	ror	r23
    2160:	67 95       	ror	r22
    2162:	b7 95       	ror	r27
    2164:	f1 11       	cpse	r31, r1
    2166:	f8 cf       	rjmp	.-16     	; 0x2158 <__floatsisf+0x1c>
    2168:	fa f4       	brpl	.+62     	; 0x21a8 <__floatsisf+0x6c>
    216a:	bb 0f       	add	r27, r27
    216c:	11 f4       	brne	.+4      	; 0x2172 <__floatsisf+0x36>
    216e:	60 ff       	sbrs	r22, 0
    2170:	1b c0       	rjmp	.+54     	; 0x21a8 <__floatsisf+0x6c>
    2172:	6f 5f       	subi	r22, 0xFF	; 255
    2174:	7f 4f       	sbci	r23, 0xFF	; 255
    2176:	8f 4f       	sbci	r24, 0xFF	; 255
    2178:	9f 4f       	sbci	r25, 0xFF	; 255
    217a:	16 c0       	rjmp	.+44     	; 0x21a8 <__floatsisf+0x6c>
    217c:	88 23       	and	r24, r24
    217e:	11 f0       	breq	.+4      	; 0x2184 <__floatsisf+0x48>
    2180:	96 e9       	ldi	r25, 0x96	; 150
    2182:	11 c0       	rjmp	.+34     	; 0x21a6 <__floatsisf+0x6a>
    2184:	77 23       	and	r23, r23
    2186:	21 f0       	breq	.+8      	; 0x2190 <__floatsisf+0x54>
    2188:	9e e8       	ldi	r25, 0x8E	; 142
    218a:	87 2f       	mov	r24, r23
    218c:	76 2f       	mov	r23, r22
    218e:	05 c0       	rjmp	.+10     	; 0x219a <__floatsisf+0x5e>
    2190:	66 23       	and	r22, r22
    2192:	71 f0       	breq	.+28     	; 0x21b0 <__floatsisf+0x74>
    2194:	96 e8       	ldi	r25, 0x86	; 134
    2196:	86 2f       	mov	r24, r22
    2198:	70 e0       	ldi	r23, 0x00	; 0
    219a:	60 e0       	ldi	r22, 0x00	; 0
    219c:	2a f0       	brmi	.+10     	; 0x21a8 <__floatsisf+0x6c>
    219e:	9a 95       	dec	r25
    21a0:	66 0f       	add	r22, r22
    21a2:	77 1f       	adc	r23, r23
    21a4:	88 1f       	adc	r24, r24
    21a6:	da f7       	brpl	.-10     	; 0x219e <__floatsisf+0x62>
    21a8:	88 0f       	add	r24, r24
    21aa:	96 95       	lsr	r25
    21ac:	87 95       	ror	r24
    21ae:	97 f9       	bld	r25, 7
    21b0:	08 95       	ret

000021b2 <__fp_cmp>:
    21b2:	99 0f       	add	r25, r25
    21b4:	00 08       	sbc	r0, r0
    21b6:	55 0f       	add	r21, r21
    21b8:	aa 0b       	sbc	r26, r26
    21ba:	e0 e8       	ldi	r30, 0x80	; 128
    21bc:	fe ef       	ldi	r31, 0xFE	; 254
    21be:	16 16       	cp	r1, r22
    21c0:	17 06       	cpc	r1, r23
    21c2:	e8 07       	cpc	r30, r24
    21c4:	f9 07       	cpc	r31, r25
    21c6:	c0 f0       	brcs	.+48     	; 0x21f8 <__fp_cmp+0x46>
    21c8:	12 16       	cp	r1, r18
    21ca:	13 06       	cpc	r1, r19
    21cc:	e4 07       	cpc	r30, r20
    21ce:	f5 07       	cpc	r31, r21
    21d0:	98 f0       	brcs	.+38     	; 0x21f8 <__fp_cmp+0x46>
    21d2:	62 1b       	sub	r22, r18
    21d4:	73 0b       	sbc	r23, r19
    21d6:	84 0b       	sbc	r24, r20
    21d8:	95 0b       	sbc	r25, r21
    21da:	39 f4       	brne	.+14     	; 0x21ea <__fp_cmp+0x38>
    21dc:	0a 26       	eor	r0, r26
    21de:	61 f0       	breq	.+24     	; 0x21f8 <__fp_cmp+0x46>
    21e0:	23 2b       	or	r18, r19
    21e2:	24 2b       	or	r18, r20
    21e4:	25 2b       	or	r18, r21
    21e6:	21 f4       	brne	.+8      	; 0x21f0 <__fp_cmp+0x3e>
    21e8:	08 95       	ret
    21ea:	0a 26       	eor	r0, r26
    21ec:	09 f4       	brne	.+2      	; 0x21f0 <__fp_cmp+0x3e>
    21ee:	a1 40       	sbci	r26, 0x01	; 1
    21f0:	a6 95       	lsr	r26
    21f2:	8f ef       	ldi	r24, 0xFF	; 255
    21f4:	81 1d       	adc	r24, r1
    21f6:	81 1d       	adc	r24, r1
    21f8:	08 95       	ret

000021fa <__fp_inf>:
    21fa:	97 f9       	bld	r25, 7
    21fc:	9f 67       	ori	r25, 0x7F	; 127
    21fe:	80 e8       	ldi	r24, 0x80	; 128
    2200:	70 e0       	ldi	r23, 0x00	; 0
    2202:	60 e0       	ldi	r22, 0x00	; 0
    2204:	08 95       	ret

00002206 <__fp_nan>:
    2206:	9f ef       	ldi	r25, 0xFF	; 255
    2208:	80 ec       	ldi	r24, 0xC0	; 192
    220a:	08 95       	ret

0000220c <__fp_pscA>:
    220c:	00 24       	eor	r0, r0
    220e:	0a 94       	dec	r0
    2210:	16 16       	cp	r1, r22
    2212:	17 06       	cpc	r1, r23
    2214:	18 06       	cpc	r1, r24
    2216:	09 06       	cpc	r0, r25
    2218:	08 95       	ret

0000221a <__fp_pscB>:
    221a:	00 24       	eor	r0, r0
    221c:	0a 94       	dec	r0
    221e:	12 16       	cp	r1, r18
    2220:	13 06       	cpc	r1, r19
    2222:	14 06       	cpc	r1, r20
    2224:	05 06       	cpc	r0, r21
    2226:	08 95       	ret

00002228 <__fp_round>:
    2228:	09 2e       	mov	r0, r25
    222a:	03 94       	inc	r0
    222c:	00 0c       	add	r0, r0
    222e:	11 f4       	brne	.+4      	; 0x2234 <__fp_round+0xc>
    2230:	88 23       	and	r24, r24
    2232:	52 f0       	brmi	.+20     	; 0x2248 <__fp_round+0x20>
    2234:	bb 0f       	add	r27, r27
    2236:	40 f4       	brcc	.+16     	; 0x2248 <__fp_round+0x20>
    2238:	bf 2b       	or	r27, r31
    223a:	11 f4       	brne	.+4      	; 0x2240 <__fp_round+0x18>
    223c:	60 ff       	sbrs	r22, 0
    223e:	04 c0       	rjmp	.+8      	; 0x2248 <__fp_round+0x20>
    2240:	6f 5f       	subi	r22, 0xFF	; 255
    2242:	7f 4f       	sbci	r23, 0xFF	; 255
    2244:	8f 4f       	sbci	r24, 0xFF	; 255
    2246:	9f 4f       	sbci	r25, 0xFF	; 255
    2248:	08 95       	ret

0000224a <__fp_split3>:
    224a:	57 fd       	sbrc	r21, 7
    224c:	90 58       	subi	r25, 0x80	; 128
    224e:	44 0f       	add	r20, r20
    2250:	55 1f       	adc	r21, r21
    2252:	59 f0       	breq	.+22     	; 0x226a <__fp_splitA+0x10>
    2254:	5f 3f       	cpi	r21, 0xFF	; 255
    2256:	71 f0       	breq	.+28     	; 0x2274 <__fp_splitA+0x1a>
    2258:	47 95       	ror	r20

0000225a <__fp_splitA>:
    225a:	88 0f       	add	r24, r24
    225c:	97 fb       	bst	r25, 7
    225e:	99 1f       	adc	r25, r25
    2260:	61 f0       	breq	.+24     	; 0x227a <__fp_splitA+0x20>
    2262:	9f 3f       	cpi	r25, 0xFF	; 255
    2264:	79 f0       	breq	.+30     	; 0x2284 <__fp_splitA+0x2a>
    2266:	87 95       	ror	r24
    2268:	08 95       	ret
    226a:	12 16       	cp	r1, r18
    226c:	13 06       	cpc	r1, r19
    226e:	14 06       	cpc	r1, r20
    2270:	55 1f       	adc	r21, r21
    2272:	f2 cf       	rjmp	.-28     	; 0x2258 <__fp_split3+0xe>
    2274:	46 95       	lsr	r20
    2276:	f1 df       	rcall	.-30     	; 0x225a <__fp_splitA>
    2278:	08 c0       	rjmp	.+16     	; 0x228a <__fp_splitA+0x30>
    227a:	16 16       	cp	r1, r22
    227c:	17 06       	cpc	r1, r23
    227e:	18 06       	cpc	r1, r24
    2280:	99 1f       	adc	r25, r25
    2282:	f1 cf       	rjmp	.-30     	; 0x2266 <__fp_splitA+0xc>
    2284:	86 95       	lsr	r24
    2286:	71 05       	cpc	r23, r1
    2288:	61 05       	cpc	r22, r1
    228a:	08 94       	sec
    228c:	08 95       	ret

0000228e <__fp_zero>:
    228e:	e8 94       	clt

00002290 <__fp_szero>:
    2290:	bb 27       	eor	r27, r27
    2292:	66 27       	eor	r22, r22
    2294:	77 27       	eor	r23, r23
    2296:	cb 01       	movw	r24, r22
    2298:	97 f9       	bld	r25, 7
    229a:	08 95       	ret

0000229c <__gesf2>:
    229c:	8a df       	rcall	.-236    	; 0x21b2 <__fp_cmp>
    229e:	08 f4       	brcc	.+2      	; 0x22a2 <__gesf2+0x6>
    22a0:	8f ef       	ldi	r24, 0xFF	; 255
    22a2:	08 95       	ret

000022a4 <__mulsf3>:
    22a4:	0b d0       	rcall	.+22     	; 0x22bc <__mulsf3x>
    22a6:	c0 cf       	rjmp	.-128    	; 0x2228 <__fp_round>
    22a8:	b1 df       	rcall	.-158    	; 0x220c <__fp_pscA>
    22aa:	28 f0       	brcs	.+10     	; 0x22b6 <__mulsf3+0x12>
    22ac:	b6 df       	rcall	.-148    	; 0x221a <__fp_pscB>
    22ae:	18 f0       	brcs	.+6      	; 0x22b6 <__mulsf3+0x12>
    22b0:	95 23       	and	r25, r21
    22b2:	09 f0       	breq	.+2      	; 0x22b6 <__mulsf3+0x12>
    22b4:	a2 cf       	rjmp	.-188    	; 0x21fa <__fp_inf>
    22b6:	a7 cf       	rjmp	.-178    	; 0x2206 <__fp_nan>
    22b8:	11 24       	eor	r1, r1
    22ba:	ea cf       	rjmp	.-44     	; 0x2290 <__fp_szero>

000022bc <__mulsf3x>:
    22bc:	c6 df       	rcall	.-116    	; 0x224a <__fp_split3>
    22be:	a0 f3       	brcs	.-24     	; 0x22a8 <__mulsf3+0x4>

000022c0 <__mulsf3_pse>:
    22c0:	95 9f       	mul	r25, r21
    22c2:	d1 f3       	breq	.-12     	; 0x22b8 <__mulsf3+0x14>
    22c4:	95 0f       	add	r25, r21
    22c6:	50 e0       	ldi	r21, 0x00	; 0
    22c8:	55 1f       	adc	r21, r21
    22ca:	62 9f       	mul	r22, r18
    22cc:	f0 01       	movw	r30, r0
    22ce:	72 9f       	mul	r23, r18
    22d0:	bb 27       	eor	r27, r27
    22d2:	f0 0d       	add	r31, r0
    22d4:	b1 1d       	adc	r27, r1
    22d6:	63 9f       	mul	r22, r19
    22d8:	aa 27       	eor	r26, r26
    22da:	f0 0d       	add	r31, r0
    22dc:	b1 1d       	adc	r27, r1
    22de:	aa 1f       	adc	r26, r26
    22e0:	64 9f       	mul	r22, r20
    22e2:	66 27       	eor	r22, r22
    22e4:	b0 0d       	add	r27, r0
    22e6:	a1 1d       	adc	r26, r1
    22e8:	66 1f       	adc	r22, r22
    22ea:	82 9f       	mul	r24, r18
    22ec:	22 27       	eor	r18, r18
    22ee:	b0 0d       	add	r27, r0
    22f0:	a1 1d       	adc	r26, r1
    22f2:	62 1f       	adc	r22, r18
    22f4:	73 9f       	mul	r23, r19
    22f6:	b0 0d       	add	r27, r0
    22f8:	a1 1d       	adc	r26, r1
    22fa:	62 1f       	adc	r22, r18
    22fc:	83 9f       	mul	r24, r19
    22fe:	a0 0d       	add	r26, r0
    2300:	61 1d       	adc	r22, r1
    2302:	22 1f       	adc	r18, r18
    2304:	74 9f       	mul	r23, r20
    2306:	33 27       	eor	r19, r19
    2308:	a0 0d       	add	r26, r0
    230a:	61 1d       	adc	r22, r1
    230c:	23 1f       	adc	r18, r19
    230e:	84 9f       	mul	r24, r20
    2310:	60 0d       	add	r22, r0
    2312:	21 1d       	adc	r18, r1
    2314:	82 2f       	mov	r24, r18
    2316:	76 2f       	mov	r23, r22
    2318:	6a 2f       	mov	r22, r26
    231a:	11 24       	eor	r1, r1
    231c:	9f 57       	subi	r25, 0x7F	; 127
    231e:	50 40       	sbci	r21, 0x00	; 0
    2320:	8a f0       	brmi	.+34     	; 0x2344 <__mulsf3_pse+0x84>
    2322:	e1 f0       	breq	.+56     	; 0x235c <__mulsf3_pse+0x9c>
    2324:	88 23       	and	r24, r24
    2326:	4a f0       	brmi	.+18     	; 0x233a <__mulsf3_pse+0x7a>
    2328:	ee 0f       	add	r30, r30
    232a:	ff 1f       	adc	r31, r31
    232c:	bb 1f       	adc	r27, r27
    232e:	66 1f       	adc	r22, r22
    2330:	77 1f       	adc	r23, r23
    2332:	88 1f       	adc	r24, r24
    2334:	91 50       	subi	r25, 0x01	; 1
    2336:	50 40       	sbci	r21, 0x00	; 0
    2338:	a9 f7       	brne	.-22     	; 0x2324 <__mulsf3_pse+0x64>
    233a:	9e 3f       	cpi	r25, 0xFE	; 254
    233c:	51 05       	cpc	r21, r1
    233e:	70 f0       	brcs	.+28     	; 0x235c <__mulsf3_pse+0x9c>
    2340:	5c cf       	rjmp	.-328    	; 0x21fa <__fp_inf>
    2342:	a6 cf       	rjmp	.-180    	; 0x2290 <__fp_szero>
    2344:	5f 3f       	cpi	r21, 0xFF	; 255
    2346:	ec f3       	brlt	.-6      	; 0x2342 <__mulsf3_pse+0x82>
    2348:	98 3e       	cpi	r25, 0xE8	; 232
    234a:	dc f3       	brlt	.-10     	; 0x2342 <__mulsf3_pse+0x82>
    234c:	86 95       	lsr	r24
    234e:	77 95       	ror	r23
    2350:	67 95       	ror	r22
    2352:	b7 95       	ror	r27
    2354:	f7 95       	ror	r31
    2356:	e7 95       	ror	r30
    2358:	9f 5f       	subi	r25, 0xFF	; 255
    235a:	c1 f7       	brne	.-16     	; 0x234c <__mulsf3_pse+0x8c>
    235c:	fe 2b       	or	r31, r30
    235e:	88 0f       	add	r24, r24
    2360:	91 1d       	adc	r25, r1
    2362:	96 95       	lsr	r25
    2364:	87 95       	ror	r24
    2366:	97 f9       	bld	r25, 7
    2368:	08 95       	ret
    236a:	11 f4       	brne	.+4      	; 0x2370 <__mulsf3_pse+0xb0>
    236c:	0e f4       	brtc	.+2      	; 0x2370 <__mulsf3_pse+0xb0>
    236e:	4b cf       	rjmp	.-362    	; 0x2206 <__fp_nan>
    2370:	3e c0       	rjmp	.+124    	; 0x23ee <__fp_mpack>

00002372 <sqrt>:
    2372:	73 df       	rcall	.-282    	; 0x225a <__fp_splitA>
    2374:	d0 f3       	brcs	.-12     	; 0x236a <__mulsf3_pse+0xaa>
    2376:	99 23       	and	r25, r25
    2378:	d9 f3       	breq	.-10     	; 0x2370 <__mulsf3_pse+0xb0>
    237a:	ce f3       	brts	.-14     	; 0x236e <__mulsf3_pse+0xae>
    237c:	9f 57       	subi	r25, 0x7F	; 127
    237e:	55 0b       	sbc	r21, r21
    2380:	87 ff       	sbrs	r24, 7
    2382:	43 d0       	rcall	.+134    	; 0x240a <__fp_norm2>
    2384:	00 24       	eor	r0, r0
    2386:	a0 e6       	ldi	r26, 0x60	; 96
    2388:	40 ea       	ldi	r20, 0xA0	; 160
    238a:	90 01       	movw	r18, r0
    238c:	80 58       	subi	r24, 0x80	; 128
    238e:	56 95       	lsr	r21
    2390:	97 95       	ror	r25
    2392:	28 f4       	brcc	.+10     	; 0x239e <sqrt+0x2c>
    2394:	80 5c       	subi	r24, 0xC0	; 192
    2396:	66 0f       	add	r22, r22
    2398:	77 1f       	adc	r23, r23
    239a:	88 1f       	adc	r24, r24
    239c:	20 f0       	brcs	.+8      	; 0x23a6 <sqrt+0x34>
    239e:	26 17       	cp	r18, r22
    23a0:	37 07       	cpc	r19, r23
    23a2:	48 07       	cpc	r20, r24
    23a4:	30 f4       	brcc	.+12     	; 0x23b2 <sqrt+0x40>
    23a6:	62 1b       	sub	r22, r18
    23a8:	73 0b       	sbc	r23, r19
    23aa:	84 0b       	sbc	r24, r20
    23ac:	20 29       	or	r18, r0
    23ae:	31 29       	or	r19, r1
    23b0:	4a 2b       	or	r20, r26
    23b2:	a6 95       	lsr	r26
    23b4:	17 94       	ror	r1
    23b6:	07 94       	ror	r0
    23b8:	20 25       	eor	r18, r0
    23ba:	31 25       	eor	r19, r1
    23bc:	4a 27       	eor	r20, r26
    23be:	58 f7       	brcc	.-42     	; 0x2396 <sqrt+0x24>
    23c0:	66 0f       	add	r22, r22
    23c2:	77 1f       	adc	r23, r23
    23c4:	88 1f       	adc	r24, r24
    23c6:	20 f0       	brcs	.+8      	; 0x23d0 <sqrt+0x5e>
    23c8:	26 17       	cp	r18, r22
    23ca:	37 07       	cpc	r19, r23
    23cc:	48 07       	cpc	r20, r24
    23ce:	30 f4       	brcc	.+12     	; 0x23dc <sqrt+0x6a>
    23d0:	62 0b       	sbc	r22, r18
    23d2:	73 0b       	sbc	r23, r19
    23d4:	84 0b       	sbc	r24, r20
    23d6:	20 0d       	add	r18, r0
    23d8:	31 1d       	adc	r19, r1
    23da:	41 1d       	adc	r20, r1
    23dc:	a0 95       	com	r26
    23de:	81 f7       	brne	.-32     	; 0x23c0 <sqrt+0x4e>
    23e0:	b9 01       	movw	r22, r18
    23e2:	84 2f       	mov	r24, r20
    23e4:	91 58       	subi	r25, 0x81	; 129
    23e6:	88 0f       	add	r24, r24
    23e8:	96 95       	lsr	r25
    23ea:	87 95       	ror	r24
    23ec:	08 95       	ret

000023ee <__fp_mpack>:
    23ee:	9f 3f       	cpi	r25, 0xFF	; 255
    23f0:	31 f0       	breq	.+12     	; 0x23fe <__fp_mpack_finite+0xc>

000023f2 <__fp_mpack_finite>:
    23f2:	91 50       	subi	r25, 0x01	; 1
    23f4:	20 f4       	brcc	.+8      	; 0x23fe <__fp_mpack_finite+0xc>
    23f6:	87 95       	ror	r24
    23f8:	77 95       	ror	r23
    23fa:	67 95       	ror	r22
    23fc:	b7 95       	ror	r27
    23fe:	88 0f       	add	r24, r24
    2400:	91 1d       	adc	r25, r1
    2402:	96 95       	lsr	r25
    2404:	87 95       	ror	r24
    2406:	97 f9       	bld	r25, 7
    2408:	08 95       	ret

0000240a <__fp_norm2>:
    240a:	91 50       	subi	r25, 0x01	; 1
    240c:	50 40       	sbci	r21, 0x00	; 0
    240e:	66 0f       	add	r22, r22
    2410:	77 1f       	adc	r23, r23
    2412:	88 1f       	adc	r24, r24
    2414:	d2 f7       	brpl	.-12     	; 0x240a <__fp_norm2>
    2416:	08 95       	ret

00002418 <__mulsi3>:
    2418:	62 9f       	mul	r22, r18
    241a:	d0 01       	movw	r26, r0
    241c:	73 9f       	mul	r23, r19
    241e:	f0 01       	movw	r30, r0
    2420:	82 9f       	mul	r24, r18
    2422:	e0 0d       	add	r30, r0
    2424:	f1 1d       	adc	r31, r1
    2426:	64 9f       	mul	r22, r20
    2428:	e0 0d       	add	r30, r0
    242a:	f1 1d       	adc	r31, r1
    242c:	92 9f       	mul	r25, r18
    242e:	f0 0d       	add	r31, r0
    2430:	83 9f       	mul	r24, r19
    2432:	f0 0d       	add	r31, r0
    2434:	74 9f       	mul	r23, r20
    2436:	f0 0d       	add	r31, r0
    2438:	65 9f       	mul	r22, r21
    243a:	f0 0d       	add	r31, r0
    243c:	99 27       	eor	r25, r25
    243e:	72 9f       	mul	r23, r18
    2440:	b0 0d       	add	r27, r0
    2442:	e1 1d       	adc	r30, r1
    2444:	f9 1f       	adc	r31, r25
    2446:	63 9f       	mul	r22, r19
    2448:	b0 0d       	add	r27, r0
    244a:	e1 1d       	adc	r30, r1
    244c:	f9 1f       	adc	r31, r25
    244e:	bd 01       	movw	r22, r26
    2450:	cf 01       	movw	r24, r30
    2452:	11 24       	eor	r1, r1
    2454:	08 95       	ret

00002456 <__udivmodhi4>:
    2456:	aa 1b       	sub	r26, r26
    2458:	bb 1b       	sub	r27, r27
    245a:	51 e1       	ldi	r21, 0x11	; 17
    245c:	07 c0       	rjmp	.+14     	; 0x246c <__udivmodhi4_ep>

0000245e <__udivmodhi4_loop>:
    245e:	aa 1f       	adc	r26, r26
    2460:	bb 1f       	adc	r27, r27
    2462:	a6 17       	cp	r26, r22
    2464:	b7 07       	cpc	r27, r23
    2466:	10 f0       	brcs	.+4      	; 0x246c <__udivmodhi4_ep>
    2468:	a6 1b       	sub	r26, r22
    246a:	b7 0b       	sbc	r27, r23

0000246c <__udivmodhi4_ep>:
    246c:	88 1f       	adc	r24, r24
    246e:	99 1f       	adc	r25, r25
    2470:	5a 95       	dec	r21
    2472:	a9 f7       	brne	.-22     	; 0x245e <__udivmodhi4_loop>
    2474:	80 95       	com	r24
    2476:	90 95       	com	r25
    2478:	bc 01       	movw	r22, r24
    247a:	cd 01       	movw	r24, r26
    247c:	08 95       	ret

0000247e <__divmodhi4>:
    247e:	97 fb       	bst	r25, 7
    2480:	09 2e       	mov	r0, r25
    2482:	07 26       	eor	r0, r23
    2484:	0a d0       	rcall	.+20     	; 0x249a <__divmodhi4_neg1>
    2486:	77 fd       	sbrc	r23, 7
    2488:	04 d0       	rcall	.+8      	; 0x2492 <__divmodhi4_neg2>
    248a:	e5 df       	rcall	.-54     	; 0x2456 <__udivmodhi4>
    248c:	06 d0       	rcall	.+12     	; 0x249a <__divmodhi4_neg1>
    248e:	00 20       	and	r0, r0
    2490:	1a f4       	brpl	.+6      	; 0x2498 <__divmodhi4_exit>

00002492 <__divmodhi4_neg2>:
    2492:	70 95       	com	r23
    2494:	61 95       	neg	r22
    2496:	7f 4f       	sbci	r23, 0xFF	; 255

00002498 <__divmodhi4_exit>:
    2498:	08 95       	ret

0000249a <__divmodhi4_neg1>:
    249a:	f6 f7       	brtc	.-4      	; 0x2498 <__divmodhi4_exit>
    249c:	90 95       	com	r25
    249e:	81 95       	neg	r24
    24a0:	9f 4f       	sbci	r25, 0xFF	; 255
    24a2:	08 95       	ret

000024a4 <__divmodsi4>:
    24a4:	97 fb       	bst	r25, 7
    24a6:	09 2e       	mov	r0, r25
    24a8:	05 26       	eor	r0, r21
    24aa:	0e d0       	rcall	.+28     	; 0x24c8 <__divmodsi4_neg1>
    24ac:	57 fd       	sbrc	r21, 7
    24ae:	04 d0       	rcall	.+8      	; 0x24b8 <__divmodsi4_neg2>
    24b0:	14 d0       	rcall	.+40     	; 0x24da <__udivmodsi4>
    24b2:	0a d0       	rcall	.+20     	; 0x24c8 <__divmodsi4_neg1>
    24b4:	00 1c       	adc	r0, r0
    24b6:	38 f4       	brcc	.+14     	; 0x24c6 <__divmodsi4_exit>

000024b8 <__divmodsi4_neg2>:
    24b8:	50 95       	com	r21
    24ba:	40 95       	com	r20
    24bc:	30 95       	com	r19
    24be:	21 95       	neg	r18
    24c0:	3f 4f       	sbci	r19, 0xFF	; 255
    24c2:	4f 4f       	sbci	r20, 0xFF	; 255
    24c4:	5f 4f       	sbci	r21, 0xFF	; 255

000024c6 <__divmodsi4_exit>:
    24c6:	08 95       	ret

000024c8 <__divmodsi4_neg1>:
    24c8:	f6 f7       	brtc	.-4      	; 0x24c6 <__divmodsi4_exit>
    24ca:	90 95       	com	r25
    24cc:	80 95       	com	r24
    24ce:	70 95       	com	r23
    24d0:	61 95       	neg	r22
    24d2:	7f 4f       	sbci	r23, 0xFF	; 255
    24d4:	8f 4f       	sbci	r24, 0xFF	; 255
    24d6:	9f 4f       	sbci	r25, 0xFF	; 255
    24d8:	08 95       	ret

000024da <__udivmodsi4>:
    24da:	a1 e2       	ldi	r26, 0x21	; 33
    24dc:	1a 2e       	mov	r1, r26
    24de:	aa 1b       	sub	r26, r26
    24e0:	bb 1b       	sub	r27, r27
    24e2:	fd 01       	movw	r30, r26
    24e4:	0d c0       	rjmp	.+26     	; 0x2500 <__udivmodsi4_ep>

000024e6 <__udivmodsi4_loop>:
    24e6:	aa 1f       	adc	r26, r26
    24e8:	bb 1f       	adc	r27, r27
    24ea:	ee 1f       	adc	r30, r30
    24ec:	ff 1f       	adc	r31, r31
    24ee:	a2 17       	cp	r26, r18
    24f0:	b3 07       	cpc	r27, r19
    24f2:	e4 07       	cpc	r30, r20
    24f4:	f5 07       	cpc	r31, r21
    24f6:	20 f0       	brcs	.+8      	; 0x2500 <__udivmodsi4_ep>
    24f8:	a2 1b       	sub	r26, r18
    24fa:	b3 0b       	sbc	r27, r19
    24fc:	e4 0b       	sbc	r30, r20
    24fe:	f5 0b       	sbc	r31, r21

00002500 <__udivmodsi4_ep>:
    2500:	66 1f       	adc	r22, r22
    2502:	77 1f       	adc	r23, r23
    2504:	88 1f       	adc	r24, r24
    2506:	99 1f       	adc	r25, r25
    2508:	1a 94       	dec	r1
    250a:	69 f7       	brne	.-38     	; 0x24e6 <__udivmodsi4_loop>
    250c:	60 95       	com	r22
    250e:	70 95       	com	r23
    2510:	80 95       	com	r24
    2512:	90 95       	com	r25
    2514:	9b 01       	movw	r18, r22
    2516:	ac 01       	movw	r20, r24
    2518:	bd 01       	movw	r22, r26
    251a:	cf 01       	movw	r24, r30
    251c:	08 95       	ret

0000251e <_exit>:
    251e:	f8 94       	cli

00002520 <__stop_program>:
    2520:	ff cf       	rjmp	.-2      	; 0x2520 <__stop_program>
